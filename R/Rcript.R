# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

##   Generated via the command line invocation:
##	 swig -r SoftPosit_R.i


#                         srun.swg                            #
#
# This is the basic code that is needed at run time within R to
# provide and define the relevant classes.  It is included
# automatically in the generated code by copying the contents of
# srun.swg into the newly created binding code.


# This could be provided as a separate run-time library but this
# approach allows the code to to be included directly into the
# generated bindings and so removes the need to have and install an
# additional library.  We may however end up with multiple copies of
# this and some confusion at run-time as to which class to use. This
# is an issue when we use NAMESPACES as we may need to export certain
# classes.

######################################################################

if(length(getClassDef("RSWIGStruct")) == 0)
  setClass("RSWIGStruct", representation("VIRTUAL"))



if(length(getClassDef("ExternalReference")) == 0)
  # Should be virtual but this means it loses its slots currently
  #representation("VIRTUAL")
  setClass("ExternalReference", representation( ref = "externalptr"))



if(length(getClassDef("NativeRoutinePointer")) == 0)
  setClass("NativeRoutinePointer",
           representation(parameterTypes = "character",
                          returnType = "character",
                          "VIRTUAL"),
           contains = "ExternalReference")

if(length(getClassDef("CRoutinePointer")) == 0)
  setClass("CRoutinePointer", contains = "NativeRoutinePointer")


if(length(getClassDef("EnumerationValue")) == 0)
  setClass("EnumerationValue", contains = "integer")


if(!isGeneric("copyToR"))
  setGeneric("copyToR",
             function(value, obj = new(gsub("Ref$", "", class(value))))
               standardGeneric("copyToR"
               ))

setGeneric("delete", function(obj) standardGeneric("delete"))


SWIG_createNewRef =
  function(className, ..., append = TRUE)
  {
    f = get(paste("new", className, sep = "_"), mode = "function")

    f(...)
  }

if(!isGeneric("copyToC"))
  setGeneric("copyToC",
             function(value, obj = SWIG_createNewRef(class(value)))
               standardGeneric("copyToC"
               ))


#
defineEnumeration =
  function(name, .values, where = topenv(parent.frame()), suffix = "Value")
  {
    # Mirror the class definitions via the E analogous to .__C__
    defName = paste(".__E__", name, sep = "")
    assign(defName,  .values,  envir = where)

    if(nchar(suffix))
      name = paste(name, suffix, sep = "")

    setClass(name, contains = "EnumerationValue", where = where)
  }

enumToInteger <- function(name,type)
{
  if (is.character(name)) {
    ans <- as.integer(get(paste(".__E__", type, sep = ""))[name])
    if (is.na(ans)) {warning("enum not found ", name, " ", type)}
    ans
  }
}

enumFromInteger =
  function(i,type)
  {
    itemlist <- get(paste(".__E__", type, sep=""))
    names(itemlist)[match(i, itemlist)]
  }

coerceIfNotSubclass =
  function(obj, type)
  {
    if(!is(obj, type)) {as(obj, type)} else obj
  }


setClass("SWIGArray", representation(dims = "integer"), contains = "ExternalReference")

setMethod("length", "SWIGArray", function(x) x@dims[1])


defineEnumeration("SCopyReferences",
                  .values = c( "FALSE" = 0, "TRUE" = 1, "DEEP" = 2))

assert =
  function(condition, message = "")
  {
    if(!condition)
      stop(message)

    TRUE
  }


if(FALSE) {
  print.SWIGFunction =
    function(x, ...)
    {
    }
}


#######################################################################

R_SWIG_getCallbackFunctionStack =
  function()
  {
    # No PACKAGE argument as we don't know what the DLL is.
    .Call("R_SWIG_debug_getCallbackFunctionData")
  }

R_SWIG_addCallbackFunctionStack =
  function(fun, userData = NULL)
  {
    # No PACKAGE argument as we don't know what the DLL is.
    .Call("R_SWIG_R_pushCallbackFunctionData", fun, userData)
  }


#######################################################################



setClass('_p_posit8_t', contains = 'ExternalReference')
setClass("posit8_t",
         representation(
           v = "integer"),
         contains = "RSWIGStruct")


# End class posit8_t

setClass('_p_posit8_t', contains = 'ExternalReference')
setClass('_p_posit16_t', contains = 'ExternalReference')
setClass("posit16_t",
         representation(
           v = "integer"),
         contains = "RSWIGStruct")


# End class posit16_t

setClass('_p_posit16_t', contains = 'ExternalReference')
setClass('_p_posit32_t', contains = 'ExternalReference')
setClass("posit32_t",
         representation(
           v = "integer"),
         contains = "RSWIGStruct")


# End class posit32_t

setClass('_p_posit32_t', contains = 'ExternalReference')
setClass('_p_posit64_t', contains = 'ExternalReference')
setClass("posit64_t",
         representation(
           v = "integer"),
         contains = "RSWIGStruct")


# End class posit64_t

setClass('_p_posit64_t', contains = 'ExternalReference')
setClass('_p_posit128_t', contains = 'ExternalReference')
setClass("posit128_t",
         representation(
           v = "integer"),
         contains = "RSWIGStruct")


# End class posit128_t

setClass('_p_posit128_t', contains = 'ExternalReference')
setClass('_p_quire8_t', contains = 'ExternalReference')
setClass("quire8_t",
         representation(
           v = "integer"),
         contains = "RSWIGStruct")


# End class quire8_t

setClass('_p_quire8_t', contains = 'ExternalReference')
setClass('_p_quire16_t', contains = 'ExternalReference')
setClass("quire16_t",
         representation(
           v = "integer"),
         contains = "RSWIGStruct")


# End class quire16_t

setClass('_p_quire16_t', contains = 'ExternalReference')
setClass('_p_quire32_t', contains = 'ExternalReference')
setClass("quire32_t",
         representation(
           v = "integer"),
         contains = "RSWIGStruct")


# End class quire32_t

setClass('_p_quire32_t', contains = 'ExternalReference')
setClass('_p_posit_2_t', contains = 'ExternalReference')
setClass("posit_2_t",
         representation(
           v = "integer"),
         contains = "RSWIGStruct")


# End class posit_2_t

setClass('_p_posit_2_t', contains = 'ExternalReference')
setClass('_p_quire_2_t', contains = 'ExternalReference')
setClass("quire_2_t",
         representation(
           v = "integer"),
         contains = "RSWIGStruct")


# End class quire_2_t

setClass('_p_quire_2_t', contains = 'ExternalReference')
setClass('_p_ui8_p8', contains = 'ExternalReference')
setClass('_p_ui16_p16', contains = 'ExternalReference')
setClass('_p_ui32_p32', contains = 'ExternalReference')
setClass('_p_ui64_p64', contains = 'ExternalReference')
setClass('_p_ui128_p128c', contains = 'ExternalReference')
setClass('_p_ui32_pX2', contains = 'ExternalReference')
setClass('_p_ui32_q8', contains = 'ExternalReference')
setClass('_p_ui128_q16', contains = 'ExternalReference')
setClass('_p_ui512_q32', contains = 'ExternalReference')
setClass('_p_ui512_qX2', contains = 'ExternalReference')



setMethod('[', "ExternalReference",
          function(x,i,j, ..., drop=TRUE)
            if (!is.null(x$"__getitem__"))
              sapply(i, function(n) x$"__getitem__"(i=as.integer(n-1))))

setMethod('[<-' , "ExternalReference",
          function(x,i,j, ..., value)
            if (!is.null(x$"__setitem__")) {
              sapply(1:length(i), function(n)
                x$"__setitem__"(i=as.integer(i[n]-1), x=value[n]))
              x
            })

setAs('ExternalReference', 'character',
      function(from) {if (!is.null(from$"__str__")) from$"__str__"()})

suppressWarnings(setMethod('print', 'ExternalReference',
                           function(x) {print(as(x, "character"))}))

# Start of posit8_t_v_set

`posit8_t_v_set` = function(self, s_v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  s_v = as.integer(s_v);

  if(length(s_v) > 1) {
    warning("using only the first element of s_v");
  };

  ;.Call('R_swig_posit8_t_v_set', self, s_v, PACKAGE='SoftPosit');

}

attr(`posit8_t_v_set`, 'returnType') = 'void'
attr(`posit8_t_v_set`, "inputTypes") = c('_p_posit8_t', 'integer')
class(`posit8_t_v_set`) = c("SWIGFunction", class('posit8_t_v_set'))

# Start of posit8_t_v_get

`posit8_t_v_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_posit8_t_v_get', self, as.logical(.copy));

}

attr(`posit8_t_v_get`, 'returnType') = 'integer'
attr(`posit8_t_v_get`, "inputTypes") = c('_p_posit8_t')
class(`posit8_t_v_get`) = c("SWIGFunction", class('posit8_t_v_get'))

# Start of posit8_t_init

`posit8_t_init` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_posit8_t_init', self, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`posit8_t_init`, 'returnType') = '_p_posit8_t'
attr(`posit8_t_init`, "inputTypes") = c('_p_posit8_t')
class(`posit8_t_init`) = c("SWIGFunction", class('posit8_t_init'))

# Start of posit8_t_fromBits

`posit8_t_fromBits` = function(self, bits)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  bits = as.integer(bits);

  if(length(bits) > 1) {
    warning("using only the first element of bits");
  };

  ;.Call('R_swig_posit8_t_fromBits', self, bits, PACKAGE='SoftPosit');

}

attr(`posit8_t_fromBits`, 'returnType') = 'void'
attr(`posit8_t_fromBits`, "inputTypes") = c('_p_posit8_t', 'integer')
class(`posit8_t_fromBits`) = c("SWIGFunction", class('posit8_t_fromBits'))

# Start of posit8_t_toBits

`posit8_t_toBits` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_posit8_t_toBits', self, PACKAGE='SoftPosit');

}

attr(`posit8_t_toBits`, 'returnType') = 'void'
attr(`posit8_t_toBits`, "inputTypes") = c('_p_posit8_t')
class(`posit8_t_toBits`) = c("SWIGFunction", class('posit8_t_toBits'))

# Start of posit8_t_toHex

`posit8_t_toHex` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_posit8_t_toHex', self, PACKAGE='SoftPosit');

}

attr(`posit8_t_toHex`, 'returnType') = 'void'
attr(`posit8_t_toHex`, "inputTypes") = c('_p_posit8_t')
class(`posit8_t_toHex`) = c("SWIGFunction", class('posit8_t_toHex'))

# Start of posit8_t_toInt

`posit8_t_toInt` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_posit8_t_toInt', self, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`posit8_t_toInt`, 'returnType') = 'integer'
attr(`posit8_t_toInt`, "inputTypes") = c('_p_posit8_t')
class(`posit8_t_toInt`) = c("SWIGFunction", class('posit8_t_toInt'))

# Start of posit8_t_rshift

`posit8_t_rshift` = function(self, n, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  n = as.integer(n);

  if(length(n) > 1) {
    warning("using only the first element of n");
  };

  ;ans = .Call('R_swig_posit8_t_rshift', self, n, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`posit8_t_rshift`, 'returnType') = '_p_posit8_t'
attr(`posit8_t_rshift`, "inputTypes") = c('_p_posit8_t', 'integer')
class(`posit8_t_rshift`) = c("SWIGFunction", class('posit8_t_rshift'))

# Start of posit8_t_lshift

`posit8_t_lshift` = function(self, n, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  n = as.integer(n);

  if(length(n) > 1) {
    warning("using only the first element of n");
  };

  ;ans = .Call('R_swig_posit8_t_lshift', self, n, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`posit8_t_lshift`, 'returnType') = '_p_posit8_t'
attr(`posit8_t_lshift`, "inputTypes") = c('_p_posit8_t', 'integer')
class(`posit8_t_lshift`) = c("SWIGFunction", class('posit8_t_lshift'))

# Start of posit8_t_invert

`posit8_t_invert` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_posit8_t_invert', self, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`posit8_t_invert`, 'returnType') = '_p_posit8_t'
attr(`posit8_t_invert`, "inputTypes") = c('_p_posit8_t')
class(`posit8_t_invert`) = c("SWIGFunction", class('posit8_t_invert'))

# Start of posit8_t_neg

`posit8_t_neg` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_posit8_t_neg', self, as.logical(.copy));
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`posit8_t_neg`, 'returnType') = '_p_posit8_t'
attr(`posit8_t_neg`, "inputTypes") = c('_p_posit8_t')
class(`posit8_t_neg`) = c("SWIGFunction", class('posit8_t_neg'))

# Start of posit8_t_abs

`posit8_t_abs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_posit8_t_abs', self, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`posit8_t_abs`, 'returnType') = '_p_posit8_t'
attr(`posit8_t_abs`, "inputTypes") = c('_p_posit8_t')
class(`posit8_t_abs`) = c("SWIGFunction", class('posit8_t_abs'))

# Start of posit8_t_and

`posit8_t_and` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(other, "ExternalReference")) other = slot(other,"ref")
  ;ans = .Call('R_swig_posit8_t_and', self, other, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`posit8_t_and`, 'returnType') = '_p_posit8_t'
attr(`posit8_t_and`, "inputTypes") = c('_p_posit8_t', '_p_posit8_t')
class(`posit8_t_and`) = c("SWIGFunction", class('posit8_t_and'))

# Start of posit8_t_xor

`posit8_t_xor` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(other, "ExternalReference")) other = slot(other,"ref")
  ;ans = .Call('R_swig_posit8_t_xor', self, other, as.logical(.copy));
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`posit8_t_xor`, 'returnType') = '_p_posit8_t'
attr(`posit8_t_xor`, "inputTypes") = c('_p_posit8_t', '_p_posit8_t')
class(`posit8_t_xor`) = c("SWIGFunction", class('posit8_t_xor'))

# Start of posit8_t_or

`posit8_t_or` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(other, "ExternalReference")) other = slot(other,"ref")
  ;ans = .Call('R_swig_posit8_t_or', self, other, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`posit8_t_or`, 'returnType') = '_p_posit8_t'
attr(`posit8_t_or`, "inputTypes") = c('_p_posit8_t', '_p_posit8_t')
class(`posit8_t_or`) = c("SWIGFunction", class('posit8_t_or'))

# Start of posit8_t_isNaR

`posit8_t_isNaR` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_posit8_t_isNaR', self, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`posit8_t_isNaR`, 'returnType') = 'logical'
attr(`posit8_t_isNaR`, "inputTypes") = c('_p_posit8_t')
class(`posit8_t_isNaR`) = c("SWIGFunction", class('posit8_t_isNaR'))

# Start of posit8_t_toNaR

`posit8_t_toNaR` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_posit8_t_toNaR', self, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`posit8_t_toNaR`, 'returnType') = '_p_posit8_t'
attr(`posit8_t_toNaR`, "inputTypes") = c('_p_posit8_t')
class(`posit8_t_toNaR`) = c("SWIGFunction", class('posit8_t_toNaR'))

# Start of new_posit8_t

`posit8_t` = function()
{
  ;ans = .Call('R_swig_new_posit8_t', PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans) ;

  reg.finalizer(ans@ref, delete_posit8_t)
  ans

}

attr(`posit8_t`, 'returnType') = '_p_posit8_t'
class(`posit8_t`) = c("SWIGFunction", class('posit8_t'))

# Start of delete_posit8_t

`delete_posit8_t` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_delete_posit8_t', self, PACKAGE='SoftPosit');

}

attr(`delete_posit8_t`, 'returnType') = 'void'
attr(`delete_posit8_t`, "inputTypes") = c('_p_posit8_t')
class(`delete_posit8_t`) = c("SWIGFunction", class('delete_posit8_t'))

# Start of accessor method for posit8_t
setMethod('$', '_p_posit8_t', function(x, name)

{
  accessorFuns = list('v' = posit8_t_v_get, 'init' = posit8_t_init, 'fromBits' = posit8_t_fromBits, 'toBits' = posit8_t_toBits, 'toHex' = posit8_t_toHex, 'toInt' = posit8_t_toInt, 'rshift' = posit8_t_rshift, 'lshift' = posit8_t_lshift, 'invert' = posit8_t_invert, 'neg' = posit8_t_neg, 'abs' = posit8_t_abs, 'and' = posit8_t_and, 'xor' = posit8_t_xor, 'or' = posit8_t_or, 'isNaR' = posit8_t_isNaR, 'toNaR' = posit8_t_toNaR);
  vaccessors = c('v');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for posit8_t
# Start of accessor method for posit8_t
setMethod('$<-', '_p_posit8_t', function(x, name, value)

{
  accessorFuns = list('v' = posit8_t_v_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_posit8_t', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('v' = posit8_t_v_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for posit8_t
setMethod('delete', '_p_posit8_t', function(obj) {delete_posit8_t(obj)})
# Start definition of copy functions & methods for posit8_t
CopyToR_posit8_t = function(value, obj = new("posit8_t"))
{
  obj@v = value$v;
  obj;
}



CopyToC_posit8_t = function(value, obj)
{
  obj$v = value@v;
  obj
}



# Start definition of copy methods for posit8_t
setMethod('copyToR', '_p_posit8_t', CopyToR_posit8_t);
setMethod('copyToC', 'posit8_t', CopyToC_posit8_t);

# End definition of copy methods for posit8_t
# End definition of copy functions & methods for posit8_t
# Start of posit16_t_v_set

`posit16_t_v_set` = function(self, s_v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  s_v = as.integer(s_v);

  if(length(s_v) > 1) {
    warning("using only the first element of s_v");
  };

  ;.Call('R_swig_posit16_t_v_set', self, s_v, PACKAGE='SoftPosit');

}

attr(`posit16_t_v_set`, 'returnType') = 'void'
attr(`posit16_t_v_set`, "inputTypes") = c('_p_posit16_t', 'integer')
class(`posit16_t_v_set`) = c("SWIGFunction", class('posit16_t_v_set'))

# Start of posit16_t_v_get

`posit16_t_v_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_posit16_t_v_get', self, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`posit16_t_v_get`, 'returnType') = 'integer'
attr(`posit16_t_v_get`, "inputTypes") = c('_p_posit16_t')
class(`posit16_t_v_get`) = c("SWIGFunction", class('posit16_t_v_get'))

# Start of posit16_t_fromBits

`posit16_t_fromBits` = function(self, bits)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  bits = as.integer(bits);

  if(length(bits) > 1) {
    warning("using only the first element of bits");
  };

  ;.Call('R_swig_posit16_t_fromBits', self, bits, PACKAGE='SoftPosit');

}

attr(`posit16_t_fromBits`, 'returnType') = 'void'
attr(`posit16_t_fromBits`, "inputTypes") = c('_p_posit16_t', 'integer')
class(`posit16_t_fromBits`) = c("SWIGFunction", class('posit16_t_fromBits'))

# Start of posit16_t_toBits

`posit16_t_toBits` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_posit16_t_toBits', self, PACKAGE='SoftPosit');

}

attr(`posit16_t_toBits`, 'returnType') = 'void'
attr(`posit16_t_toBits`, "inputTypes") = c('_p_posit16_t')
class(`posit16_t_toBits`) = c("SWIGFunction", class('posit16_t_toBits'))

# Start of posit16_t_toHex

`posit16_t_toHex` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_posit16_t_toHex', self, PACKAGE='SoftPosit');

}

attr(`posit16_t_toHex`, 'returnType') = 'void'
attr(`posit16_t_toHex`, "inputTypes") = c('_p_posit16_t')
class(`posit16_t_toHex`) = c("SWIGFunction", class('posit16_t_toHex'))

# Start of posit16_t_toInt

`posit16_t_toInt` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_posit16_t_toInt', self, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`posit16_t_toInt`, 'returnType') = 'integer'
attr(`posit16_t_toInt`, "inputTypes") = c('_p_posit16_t')
class(`posit16_t_toInt`) = c("SWIGFunction", class('posit16_t_toInt'))

# Start of posit16_t_rshift

`posit16_t_rshift` = function(self, n, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  n = as.integer(n);

  if(length(n) > 1) {
    warning("using only the first element of n");
  };

  ;ans = .Call('R_swig_posit16_t_rshift', self, n, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`posit16_t_rshift`, 'returnType') = '_p_posit16_t'
attr(`posit16_t_rshift`, "inputTypes") = c('_p_posit16_t', 'integer')
class(`posit16_t_rshift`) = c("SWIGFunction", class('posit16_t_rshift'))

# Start of posit16_t_lshift

`posit16_t_lshift` = function(self, n, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  n = as.integer(n);

  if(length(n) > 1) {
    warning("using only the first element of n");
  };

  ;ans = .Call('R_swig_posit16_t_lshift', self, n, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`posit16_t_lshift`, 'returnType') = '_p_posit16_t'
attr(`posit16_t_lshift`, "inputTypes") = c('_p_posit16_t', 'integer')
class(`posit16_t_lshift`) = c("SWIGFunction", class('posit16_t_lshift'))

# Start of posit16_t_invert

`posit16_t_invert` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_posit16_t_invert', self, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`posit16_t_invert`, 'returnType') = '_p_posit16_t'
attr(`posit16_t_invert`, "inputTypes") = c('_p_posit16_t')
class(`posit16_t_invert`) = c("SWIGFunction", class('posit16_t_invert'))

# Start of posit16_t_neg

`posit16_t_neg` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_posit16_t_neg', self, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`posit16_t_neg`, 'returnType') = '_p_posit16_t'
attr(`posit16_t_neg`, "inputTypes") = c('_p_posit16_t')
class(`posit16_t_neg`) = c("SWIGFunction", class('posit16_t_neg'))

# Start of posit16_t_abs

`posit16_t_abs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_posit16_t_abs', self, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`posit16_t_abs`, 'returnType') = '_p_posit16_t'
attr(`posit16_t_abs`, "inputTypes") = c('_p_posit16_t')
class(`posit16_t_abs`) = c("SWIGFunction", class('posit16_t_abs'))

# Start of posit16_t_and

`posit16_t_and` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(other, "ExternalReference")) other = slot(other,"ref")
  ;ans = .Call('R_swig_posit16_t_and', self, other, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`posit16_t_and`, 'returnType') = '_p_posit16_t'
attr(`posit16_t_and`, "inputTypes") = c('_p_posit16_t', '_p_posit16_t')
class(`posit16_t_and`) = c("SWIGFunction", class('posit16_t_and'))

# Start of posit16_t_xor

`posit16_t_xor` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(other, "ExternalReference")) other = slot(other,"ref")
  ;ans = .Call('R_swig_posit16_t_xor', self, other, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`posit16_t_xor`, 'returnType') = '_p_posit16_t'
attr(`posit16_t_xor`, "inputTypes") = c('_p_posit16_t', '_p_posit16_t')
class(`posit16_t_xor`) = c("SWIGFunction", class('posit16_t_xor'))

# Start of posit16_t_or

`posit16_t_or` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(other, "ExternalReference")) other = slot(other,"ref")
  ;ans = .Call('R_swig_posit16_t_or', self, other, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`posit16_t_or`, 'returnType') = '_p_posit16_t'
attr(`posit16_t_or`, "inputTypes") = c('_p_posit16_t', '_p_posit16_t')
class(`posit16_t_or`) = c("SWIGFunction", class('posit16_t_or'))

# Start of posit16_t_isNaR

`posit16_t_isNaR` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_posit16_t_isNaR', self, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`posit16_t_isNaR`, 'returnType') = 'logical'
attr(`posit16_t_isNaR`, "inputTypes") = c('_p_posit16_t')
class(`posit16_t_isNaR`) = c("SWIGFunction", class('posit16_t_isNaR'))

# Start of posit16_t_toNaR

`posit16_t_toNaR` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_posit16_t_toNaR', self, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`posit16_t_toNaR`, 'returnType') = '_p_posit16_t'
attr(`posit16_t_toNaR`, "inputTypes") = c('_p_posit16_t')
class(`posit16_t_toNaR`) = c("SWIGFunction", class('posit16_t_toNaR'))

# Start of new_posit16_t

`posit16_t` = function()
{
  ;ans = .Call('R_swig_new_posit16_t', PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans) ;

  reg.finalizer(ans@ref, delete_posit16_t)
  ans

}

attr(`posit16_t`, 'returnType') = '_p_posit16_t'
class(`posit16_t`) = c("SWIGFunction", class('posit16_t'))

# Start of delete_posit16_t

`delete_posit16_t` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_delete_posit16_t', self, PACKAGE='SoftPosit');

}

attr(`delete_posit16_t`, 'returnType') = 'void'
attr(`delete_posit16_t`, "inputTypes") = c('_p_posit16_t')
class(`delete_posit16_t`) = c("SWIGFunction", class('delete_posit16_t'))

# Start of accessor method for posit16_t
setMethod('$', '_p_posit16_t', function(x, name)

{
  accessorFuns = list('v' = posit16_t_v_get, 'fromBits' = posit16_t_fromBits, 'toBits' = posit16_t_toBits, 'toHex' = posit16_t_toHex, 'toInt' = posit16_t_toInt, 'rshift' = posit16_t_rshift, 'lshift' = posit16_t_lshift, 'invert' = posit16_t_invert, 'neg' = posit16_t_neg, 'abs' = posit16_t_abs, 'and' = posit16_t_and, 'xor' = posit16_t_xor, 'or' = posit16_t_or, 'isNaR' = posit16_t_isNaR, 'toNaR' = posit16_t_toNaR);
  vaccessors = c('v');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for posit16_t
# Start of accessor method for posit16_t
setMethod('$<-', '_p_posit16_t', function(x, name, value)

{
  accessorFuns = list('v' = posit16_t_v_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_posit16_t', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('v' = posit16_t_v_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for posit16_t
setMethod('delete', '_p_posit16_t', function(obj) {delete_posit16_t(obj)})
# Start definition of copy functions & methods for posit16_t
CopyToR_posit16_t = function(value, obj = new("posit16_t"))
{
  obj@v = value$v;
  obj;
}



CopyToC_posit16_t = function(value, obj)
{
  obj$v = value@v;
  obj
}



# Start definition of copy methods for posit16_t
setMethod('copyToR', '_p_posit16_t', CopyToR_posit16_t);
setMethod('copyToC', 'posit16_t', CopyToC_posit16_t);

# End definition of copy methods for posit16_t
# End definition of copy functions & methods for posit16_t
# Start of posit32_t_v_set

`posit32_t_v_set` = function(self, s_v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  s_v = as.integer(s_v);

  if(length(s_v) > 1) {
    warning("using only the first element of s_v");
  };

  ;.Call('R_swig_posit32_t_v_set', self, s_v, PACKAGE='SoftPosit');

}

attr(`posit32_t_v_set`, 'returnType') = 'void'
attr(`posit32_t_v_set`, "inputTypes") = c('_p_posit32_t', 'integer')
class(`posit32_t_v_set`) = c("SWIGFunction", class('posit32_t_v_set'))

# Start of posit32_t_v_get

`posit32_t_v_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_posit32_t_v_get', self, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`posit32_t_v_get`, 'returnType') = 'integer'
attr(`posit32_t_v_get`, "inputTypes") = c('_p_posit32_t')
class(`posit32_t_v_get`) = c("SWIGFunction", class('posit32_t_v_get'))

# Start of posit32_t_fromBits

`posit32_t_fromBits` = function(self, bits)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  bits = as.integer(bits);

  if(length(bits) > 1) {
    warning("using only the first element of bits");
  };

  ;.Call('R_swig_posit32_t_fromBits', self, bits, PACKAGE='SoftPosit');

}

attr(`posit32_t_fromBits`, 'returnType') = 'void'
attr(`posit32_t_fromBits`, "inputTypes") = c('_p_posit32_t', 'integer')
class(`posit32_t_fromBits`) = c("SWIGFunction", class('posit32_t_fromBits'))

# Start of posit32_t_toBits

`posit32_t_toBits` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_posit32_t_toBits', self, PACKAGE='SoftPosit');

}

attr(`posit32_t_toBits`, 'returnType') = 'void'
attr(`posit32_t_toBits`, "inputTypes") = c('_p_posit32_t')
class(`posit32_t_toBits`) = c("SWIGFunction", class('posit32_t_toBits'))

# Start of posit32_t_toHex

`posit32_t_toHex` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_posit32_t_toHex', self, PACKAGE='SoftPosit');

}

attr(`posit32_t_toHex`, 'returnType') = 'void'
attr(`posit32_t_toHex`, "inputTypes") = c('_p_posit32_t')
class(`posit32_t_toHex`) = c("SWIGFunction", class('posit32_t_toHex'))

# Start of posit32_t_toInt

`posit32_t_toInt` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_posit32_t_toInt', self, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`posit32_t_toInt`, 'returnType') = 'integer'
attr(`posit32_t_toInt`, "inputTypes") = c('_p_posit32_t')
class(`posit32_t_toInt`) = c("SWIGFunction", class('posit32_t_toInt'))

# Start of posit32_t_rshift

`posit32_t_rshift` = function(self, n, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  n = as.integer(n);

  if(length(n) > 1) {
    warning("using only the first element of n");
  };

  ;ans = .Call('R_swig_posit32_t_rshift', self, n, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`posit32_t_rshift`, 'returnType') = '_p_posit32_t'
attr(`posit32_t_rshift`, "inputTypes") = c('_p_posit32_t', 'integer')
class(`posit32_t_rshift`) = c("SWIGFunction", class('posit32_t_rshift'))

# Start of posit32_t_lshift

`posit32_t_lshift` = function(self, n, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  n = as.integer(n);

  if(length(n) > 1) {
    warning("using only the first element of n");
  };

  ;ans = .Call('R_swig_posit32_t_lshift', self, n, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`posit32_t_lshift`, 'returnType') = '_p_posit32_t'
attr(`posit32_t_lshift`, "inputTypes") = c('_p_posit32_t', 'integer')
class(`posit32_t_lshift`) = c("SWIGFunction", class('posit32_t_lshift'))

# Start of posit32_t_invert

`posit32_t_invert` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_posit32_t_invert', self, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`posit32_t_invert`, 'returnType') = '_p_posit32_t'
attr(`posit32_t_invert`, "inputTypes") = c('_p_posit32_t')
class(`posit32_t_invert`) = c("SWIGFunction", class('posit32_t_invert'))

# Start of posit32_t_neg

`posit32_t_neg` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_posit32_t_neg', self, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`posit32_t_neg`, 'returnType') = '_p_posit32_t'
attr(`posit32_t_neg`, "inputTypes") = c('_p_posit32_t')
class(`posit32_t_neg`) = c("SWIGFunction", class('posit32_t_neg'))

# Start of posit32_t_abs

`posit32_t_abs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_posit32_t_abs', self, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`posit32_t_abs`, 'returnType') = '_p_posit32_t'
attr(`posit32_t_abs`, "inputTypes") = c('_p_posit32_t')
class(`posit32_t_abs`) = c("SWIGFunction", class('posit32_t_abs'))

# Start of posit32_t_and

`posit32_t_and` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(other, "ExternalReference")) other = slot(other,"ref")
  ;ans = .Call('R_swig_posit32_t_and', self, other, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`posit32_t_and`, 'returnType') = '_p_posit32_t'
attr(`posit32_t_and`, "inputTypes") = c('_p_posit32_t', '_p_posit32_t')
class(`posit32_t_and`) = c("SWIGFunction", class('posit32_t_and'))

# Start of posit32_t_xor

`posit32_t_xor` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(other, "ExternalReference")) other = slot(other,"ref")
  ;ans = .Call('R_swig_posit32_t_xor', self, other, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`posit32_t_xor`, 'returnType') = '_p_posit32_t'
attr(`posit32_t_xor`, "inputTypes") = c('_p_posit32_t', '_p_posit32_t')
class(`posit32_t_xor`) = c("SWIGFunction", class('posit32_t_xor'))

# Start of posit32_t_or

`posit32_t_or` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(other, "ExternalReference")) other = slot(other,"ref")
  ;ans = .Call('R_swig_posit32_t_or', self, other, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`posit32_t_or`, 'returnType') = '_p_posit32_t'
attr(`posit32_t_or`, "inputTypes") = c('_p_posit32_t', '_p_posit32_t')
class(`posit32_t_or`) = c("SWIGFunction", class('posit32_t_or'))

# Start of posit32_t_isNaR

`posit32_t_isNaR` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_posit32_t_isNaR', self, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`posit32_t_isNaR`, 'returnType') = 'logical'
attr(`posit32_t_isNaR`, "inputTypes") = c('_p_posit32_t')
class(`posit32_t_isNaR`) = c("SWIGFunction", class('posit32_t_isNaR'))

# Start of posit32_t_toNaR

`posit32_t_toNaR` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_posit32_t_toNaR', self, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`posit32_t_toNaR`, 'returnType') = '_p_posit32_t'
attr(`posit32_t_toNaR`, "inputTypes") = c('_p_posit32_t')
class(`posit32_t_toNaR`) = c("SWIGFunction", class('posit32_t_toNaR'))

# Start of new_posit32_t

`posit32_t` = function()
{
  ;ans = .Call('R_swig_new_posit32_t', PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans) ;

  reg.finalizer(ans@ref, delete_posit32_t)
  ans

}

attr(`posit32_t`, 'returnType') = '_p_posit32_t'
class(`posit32_t`) = c("SWIGFunction", class('posit32_t'))

# Start of delete_posit32_t

`delete_posit32_t` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_delete_posit32_t', self, PACKAGE='SoftPosit');

}

attr(`delete_posit32_t`, 'returnType') = 'void'
attr(`delete_posit32_t`, "inputTypes") = c('_p_posit32_t')
class(`delete_posit32_t`) = c("SWIGFunction", class('delete_posit32_t'))

# Start of accessor method for posit32_t
setMethod('$', '_p_posit32_t', function(x, name)

{
  accessorFuns = list('v' = posit32_t_v_get, 'fromBits' = posit32_t_fromBits, 'toBits' = posit32_t_toBits, 'toHex' = posit32_t_toHex, 'toInt' = posit32_t_toInt, 'rshift' = posit32_t_rshift, 'lshift' = posit32_t_lshift, 'invert' = posit32_t_invert, 'neg' = posit32_t_neg, 'abs' = posit32_t_abs, 'and' = posit32_t_and, 'xor' = posit32_t_xor, 'or' = posit32_t_or, 'isNaR' = posit32_t_isNaR, 'toNaR' = posit32_t_toNaR);
  vaccessors = c('v');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for posit32_t
# Start of accessor method for posit32_t
setMethod('$<-', '_p_posit32_t', function(x, name, value)

{
  accessorFuns = list('v' = posit32_t_v_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_posit32_t', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('v' = posit32_t_v_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for posit32_t
setMethod('delete', '_p_posit32_t', function(obj) {delete_posit32_t(obj)})
# Start definition of copy functions & methods for posit32_t
CopyToR_posit32_t = function(value, obj = new("posit32_t"))
{
  obj@v = value$v;
  obj;
}



CopyToC_posit32_t = function(value, obj)
{
  obj$v = value@v;
  obj
}



# Start definition of copy methods for posit32_t
setMethod('copyToR', '_p_posit32_t', CopyToR_posit32_t);
setMethod('copyToC', 'posit32_t', CopyToC_posit32_t);

# End definition of copy methods for posit32_t
# End definition of copy functions & methods for posit32_t
# Start of posit64_t_v_set

`posit64_t_v_set` = function(self, s_v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  s_v = as.integer(s_v);

  if(length(s_v) > 1) {
    warning("using only the first element of s_v");
  };

  ;.Call('R_swig_posit64_t_v_set', self, s_v, PACKAGE='SoftPosit');

}

attr(`posit64_t_v_set`, 'returnType') = 'void'
attr(`posit64_t_v_set`, "inputTypes") = c('_p_posit64_t', 'integer')
class(`posit64_t_v_set`) = c("SWIGFunction", class('posit64_t_v_set'))

# Start of posit64_t_v_get

`posit64_t_v_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_posit64_t_v_get', self, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`posit64_t_v_get`, 'returnType') = 'integer'
attr(`posit64_t_v_get`, "inputTypes") = c('_p_posit64_t')
class(`posit64_t_v_get`) = c("SWIGFunction", class('posit64_t_v_get'))

# Start of new_posit64_t

`posit64_t` = function()
{
  ;ans = .Call('R_swig_new_posit64_t', PACKAGE='SoftPosit');
  ans <- new("_p_posit64_t", ref=ans) ;

  reg.finalizer(ans@ref, delete_posit64_t)
  ans

}

attr(`posit64_t`, 'returnType') = '_p_posit64_t'
class(`posit64_t`) = c("SWIGFunction", class('posit64_t'))

# Start of delete_posit64_t

`delete_posit64_t` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_delete_posit64_t', self, PACKAGE='SoftPosit');

}

attr(`delete_posit64_t`, 'returnType') = 'void'
attr(`delete_posit64_t`, "inputTypes") = c('_p_posit64_t')
class(`delete_posit64_t`) = c("SWIGFunction", class('delete_posit64_t'))

# Start of accessor method for posit64_t
setMethod('$', '_p_posit64_t', function(x, name)

{
  accessorFuns = list('v' = posit64_t_v_get);
  vaccessors = c('v');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for posit64_t
# Start of accessor method for posit64_t
setMethod('$<-', '_p_posit64_t', function(x, name, value)

{
  accessorFuns = list('v' = posit64_t_v_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_posit64_t', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('v' = posit64_t_v_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for posit64_t
setMethod('delete', '_p_posit64_t', function(obj) {delete_posit64_t(obj)})
# Start definition of copy functions & methods for posit64_t
CopyToR_posit64_t = function(value, obj = new("posit64_t"))
{
  obj@v = value$v;
  obj;
}



CopyToC_posit64_t = function(value, obj)
{
  obj$v = value@v;
  obj
}



# Start definition of copy methods for posit64_t
setMethod('copyToR', '_p_posit64_t', CopyToR_posit64_t);
setMethod('copyToC', 'posit64_t', CopyToC_posit64_t);

# End definition of copy methods for posit64_t
# End definition of copy functions & methods for posit64_t
# Start of posit128_t_v_set

`posit128_t_v_set` = function(self, s_v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  s_v = as.integer(s_v);

  #  assert(length(s_v) >= 2)

  ;.Call('R_swig_posit128_t_v_set', self, s_v, PACKAGE='SoftPosit');

}

attr(`posit128_t_v_set`, 'returnType') = 'void'
attr(`posit128_t_v_set`, "inputTypes") = c('_p_posit128_t', 'integer')
class(`posit128_t_v_set`) = c("SWIGFunction", class('posit128_t_v_set'))

# Start of posit128_t_v_get

`posit128_t_v_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_posit128_t_v_get', self, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_unsigned_long_long", ref=ans) ;

  ans

}

attr(`posit128_t_v_get`, 'returnType') = 'integer'
attr(`posit128_t_v_get`, "inputTypes") = c('_p_posit128_t')
class(`posit128_t_v_get`) = c("SWIGFunction", class('posit128_t_v_get'))

# Start of new_posit128_t

`posit128_t` = function()
{
  ;ans = .Call('R_swig_new_posit128_t', PACKAGE='SoftPosit');
  ans <- new("_p_posit128_t", ref=ans) ;

  reg.finalizer(ans@ref, delete_posit128_t)
  ans

}

attr(`posit128_t`, 'returnType') = '_p_posit128_t'
class(`posit128_t`) = c("SWIGFunction", class('posit128_t'))

# Start of delete_posit128_t

`delete_posit128_t` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_delete_posit128_t', self, PACKAGE='SoftPosit');

}

attr(`delete_posit128_t`, 'returnType') = 'void'
attr(`delete_posit128_t`, "inputTypes") = c('_p_posit128_t')
class(`delete_posit128_t`) = c("SWIGFunction", class('delete_posit128_t'))

# Start of accessor method for posit128_t
setMethod('$', '_p_posit128_t', function(x, name)

{
  accessorFuns = list('v' = posit128_t_v_get);
  vaccessors = c('v');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for posit128_t
# Start of accessor method for posit128_t
setMethod('$<-', '_p_posit128_t', function(x, name, value)

{
  accessorFuns = list('v' = posit128_t_v_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_posit128_t', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('v' = posit128_t_v_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for posit128_t
setMethod('delete', '_p_posit128_t', function(obj) {delete_posit128_t(obj)})
# Start definition of copy functions & methods for posit128_t
CopyToR_posit128_t = function(value, obj = new("posit128_t"))
{
  obj@v = value$v;
  obj;
}



CopyToC_posit128_t = function(value, obj)
{
  obj$v = value@v;
  obj
}



# Start definition of copy methods for posit128_t
setMethod('copyToR', '_p_posit128_t', CopyToR_posit128_t);
setMethod('copyToC', 'posit128_t', CopyToC_posit128_t);

# End definition of copy methods for posit128_t
# End definition of copy functions & methods for posit128_t
# Start of quire8_t_v_set

`quire8_t_v_set` = function(self, s_v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  s_v = as.integer(s_v);

  if(length(s_v) > 1) {
    warning("using only the first element of s_v");
  };

  ;.Call('R_swig_quire8_t_v_set', self, s_v, PACKAGE='SoftPosit');

}

attr(`quire8_t_v_set`, 'returnType') = 'void'
attr(`quire8_t_v_set`, "inputTypes") = c('_p_quire8_t', 'integer')
class(`quire8_t_v_set`) = c("SWIGFunction", class('quire8_t_v_set'))

# Start of quire8_t_v_get

`quire8_t_v_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_quire8_t_v_get', self, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`quire8_t_v_get`, 'returnType') = 'integer'
attr(`quire8_t_v_get`, "inputTypes") = c('_p_quire8_t')
class(`quire8_t_v_get`) = c("SWIGFunction", class('quire8_t_v_get'))

# Start of new_quire8_t

`quire8_t` = function()
{
  ;ans = .Call('R_swig_new_quire8_t', PACKAGE='SoftPosit');
  ans <- new("_p_quire8_t", ref=ans) ;

  reg.finalizer(ans@ref, delete_quire8_t)
  ans

}

attr(`quire8_t`, 'returnType') = '_p_quire8_t'
class(`quire8_t`) = c("SWIGFunction", class('quire8_t'))

# Start of quire8_t_toBits

`quire8_t_toBits` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_quire8_t_toBits', self, PACKAGE='SoftPosit');

}

attr(`quire8_t_toBits`, 'returnType') = 'void'
attr(`quire8_t_toBits`, "inputTypes") = c('_p_quire8_t')
class(`quire8_t_toBits`) = c("SWIGFunction", class('quire8_t_toBits'))

# Start of quire8_t_toHex

`quire8_t_toHex` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_quire8_t_toHex', self, PACKAGE='SoftPosit');

}

attr(`quire8_t_toHex`, 'returnType') = 'void'
attr(`quire8_t_toHex`, "inputTypes") = c('_p_quire8_t')
class(`quire8_t_toHex`) = c("SWIGFunction", class('quire8_t_toHex'))

# Start of quire8_t_clr

`quire8_t_clr` = function(self, q, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(q, "ExternalReference")) q = slot(q,"ref")
  ;ans = .Call('R_swig_quire8_t_clr', self, q, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_quire8_t", ref=ans);

  ans

}

attr(`quire8_t_clr`, 'returnType') = '_p_quire8_t'
attr(`quire8_t_clr`, "inputTypes") = c('_p_quire8_t', '_p_quire8_t')
class(`quire8_t_clr`) = c("SWIGFunction", class('quire8_t_clr'))

# Start of quire8_t_isNaR

`quire8_t_isNaR` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_quire8_t_isNaR', self, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`quire8_t_isNaR`, 'returnType') = 'logical'
attr(`quire8_t_isNaR`, "inputTypes") = c('_p_quire8_t')
class(`quire8_t_isNaR`) = c("SWIGFunction", class('quire8_t_isNaR'))

# Start of delete_quire8_t

`delete_quire8_t` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_delete_quire8_t', self, PACKAGE='SoftPosit');

}

attr(`delete_quire8_t`, 'returnType') = 'void'
attr(`delete_quire8_t`, "inputTypes") = c('_p_quire8_t')
class(`delete_quire8_t`) = c("SWIGFunction", class('delete_quire8_t'))

# Start of accessor method for quire8_t
setMethod('$', '_p_quire8_t', function(x, name)

{
  accessorFuns = list('v' = quire8_t_v_get, 'toBits' = quire8_t_toBits, 'toHex' = quire8_t_toHex, 'clr' = quire8_t_clr, 'isNaR' = quire8_t_isNaR);
  vaccessors = c('v');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for quire8_t
# Start of accessor method for quire8_t
setMethod('$<-', '_p_quire8_t', function(x, name, value)

{
  accessorFuns = list('v' = quire8_t_v_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_quire8_t', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('v' = quire8_t_v_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for quire8_t
setMethod('delete', '_p_quire8_t', function(obj) {delete_quire8_t(obj)})
# Start definition of copy functions & methods for quire8_t
CopyToR_quire8_t = function(value, obj = new("quire8_t"))
{
  obj@v = value$v;
  obj;
}



CopyToC_quire8_t = function(value, obj)
{
  obj$v = value@v;
  obj
}



# Start definition of copy methods for quire8_t
setMethod('copyToR', '_p_quire8_t', CopyToR_quire8_t);
setMethod('copyToC', 'quire8_t', CopyToC_quire8_t);

# End definition of copy methods for quire8_t
# End definition of copy functions & methods for quire8_t
# Start of quire16_t_v_set

`quire16_t_v_set` = function(self, s_v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  s_v = as.integer(s_v);

  #  assert(length(s_v) >= 2)

  ;.Call('R_swig_quire16_t_v_set', self, s_v, PACKAGE='SoftPosit');

}

attr(`quire16_t_v_set`, 'returnType') = 'void'
attr(`quire16_t_v_set`, "inputTypes") = c('_p_quire16_t', 'integer')
class(`quire16_t_v_set`) = c("SWIGFunction", class('quire16_t_v_set'))

# Start of quire16_t_v_get

`quire16_t_v_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_quire16_t_v_get', self, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_unsigned_long_long", ref=ans) ;

  ans

}

attr(`quire16_t_v_get`, 'returnType') = 'integer'
attr(`quire16_t_v_get`, "inputTypes") = c('_p_quire16_t')
class(`quire16_t_v_get`) = c("SWIGFunction", class('quire16_t_v_get'))

# Start of new_quire16_t

`quire16_t` = function()
{
  ;ans = .Call('R_swig_new_quire16_t', PACKAGE='SoftPosit');
  ans <- new("_p_quire16_t", ref=ans) ;

  reg.finalizer(ans@ref, delete_quire16_t)
  ans

}

attr(`quire16_t`, 'returnType') = '_p_quire16_t'
class(`quire16_t`) = c("SWIGFunction", class('quire16_t'))

# Start of quire16_t_toBits

`quire16_t_toBits` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_quire16_t_toBits', self, PACKAGE='SoftPosit');

}

attr(`quire16_t_toBits`, 'returnType') = 'void'
attr(`quire16_t_toBits`, "inputTypes") = c('_p_quire16_t')
class(`quire16_t_toBits`) = c("SWIGFunction", class('quire16_t_toBits'))

# Start of quire16_t_toHex

`quire16_t_toHex` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_quire16_t_toHex', self, PACKAGE='SoftPosit');

}

attr(`quire16_t_toHex`, 'returnType') = 'void'
attr(`quire16_t_toHex`, "inputTypes") = c('_p_quire16_t')
class(`quire16_t_toHex`) = c("SWIGFunction", class('quire16_t_toHex'))

# Start of quire16_t_clr

`quire16_t_clr` = function(self, q, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(q, "ExternalReference")) q = slot(q,"ref")
  ;ans = .Call('R_swig_quire16_t_clr', self, q, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_quire16_t", ref=ans);

  ans

}

attr(`quire16_t_clr`, 'returnType') = '_p_quire16_t'
attr(`quire16_t_clr`, "inputTypes") = c('_p_quire16_t', '_p_quire16_t')
class(`quire16_t_clr`) = c("SWIGFunction", class('quire16_t_clr'))

# Start of quire16_t_isNaR

`quire16_t_isNaR` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_quire16_t_isNaR', self, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`quire16_t_isNaR`, 'returnType') = 'logical'
attr(`quire16_t_isNaR`, "inputTypes") = c('_p_quire16_t')
class(`quire16_t_isNaR`) = c("SWIGFunction", class('quire16_t_isNaR'))

# Start of delete_quire16_t

`delete_quire16_t` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_delete_quire16_t', self, PACKAGE='SoftPosit');

}

attr(`delete_quire16_t`, 'returnType') = 'void'
attr(`delete_quire16_t`, "inputTypes") = c('_p_quire16_t')
class(`delete_quire16_t`) = c("SWIGFunction", class('delete_quire16_t'))

# Start of accessor method for quire16_t
setMethod('$', '_p_quire16_t', function(x, name)

{
  accessorFuns = list('v' = quire16_t_v_get, 'toBits' = quire16_t_toBits, 'toHex' = quire16_t_toHex, 'clr' = quire16_t_clr, 'isNaR' = quire16_t_isNaR);
  vaccessors = c('v');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for quire16_t
# Start of accessor method for quire16_t
setMethod('$<-', '_p_quire16_t', function(x, name, value)

{
  accessorFuns = list('v' = quire16_t_v_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_quire16_t', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('v' = quire16_t_v_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for quire16_t
setMethod('delete', '_p_quire16_t', function(obj) {delete_quire16_t(obj)})
# Start definition of copy functions & methods for quire16_t
CopyToR_quire16_t = function(value, obj = new("quire16_t"))
{
  obj@v = value$v;
  obj;
}



CopyToC_quire16_t = function(value, obj)
{
  obj$v = value@v;
  obj
}



# Start definition of copy methods for quire16_t
setMethod('copyToR', '_p_quire16_t', CopyToR_quire16_t);
setMethod('copyToC', 'quire16_t', CopyToC_quire16_t);

# End definition of copy methods for quire16_t
# End definition of copy functions & methods for quire16_t
# Start of quire32_t_v_set

`quire32_t_v_set` = function(self, s_v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  s_v = as.integer(s_v);

  #  assert(length(s_v) >= 8)

  ;.Call('R_swig_quire32_t_v_set', self, s_v, PACKAGE='SoftPosit');

}

attr(`quire32_t_v_set`, 'returnType') = 'void'
attr(`quire32_t_v_set`, "inputTypes") = c('_p_quire32_t', 'integer')
class(`quire32_t_v_set`) = c("SWIGFunction", class('quire32_t_v_set'))

# Start of quire32_t_v_get

`quire32_t_v_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_quire32_t_v_get', self, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_unsigned_long_long", ref=ans) ;

  ans

}

attr(`quire32_t_v_get`, 'returnType') = 'integer'
attr(`quire32_t_v_get`, "inputTypes") = c('_p_quire32_t')
class(`quire32_t_v_get`) = c("SWIGFunction", class('quire32_t_v_get'))

# Start of new_quire32_t

`quire32_t` = function()
{
  ;ans = .Call('R_swig_new_quire32_t', PACKAGE='SoftPosit');
  ans <- new("_p_quire32_t", ref=ans) ;

  reg.finalizer(ans@ref, delete_quire32_t)
  ans

}

attr(`quire32_t`, 'returnType') = '_p_quire32_t'
class(`quire32_t`) = c("SWIGFunction", class('quire32_t'))

# Start of quire32_t_toBits

`quire32_t_toBits` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_quire32_t_toBits', self, PACKAGE='SoftPosit');

}

attr(`quire32_t_toBits`, 'returnType') = 'void'
attr(`quire32_t_toBits`, "inputTypes") = c('_p_quire32_t')
class(`quire32_t_toBits`) = c("SWIGFunction", class('quire32_t_toBits'))

# Start of quire32_t_toHex

`quire32_t_toHex` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_quire32_t_toHex', self, PACKAGE='SoftPosit');

}

attr(`quire32_t_toHex`, 'returnType') = 'void'
attr(`quire32_t_toHex`, "inputTypes") = c('_p_quire32_t')
class(`quire32_t_toHex`) = c("SWIGFunction", class('quire32_t_toHex'))

# Start of quire32_t_clr

`quire32_t_clr` = function(self, q, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(q, "ExternalReference")) q = slot(q,"ref")
  ;ans = .Call('R_swig_quire32_t_clr', self, q, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_quire32_t", ref=ans);

  ans

}

attr(`quire32_t_clr`, 'returnType') = '_p_quire32_t'
attr(`quire32_t_clr`, "inputTypes") = c('_p_quire32_t', '_p_quire32_t')
class(`quire32_t_clr`) = c("SWIGFunction", class('quire32_t_clr'))

# Start of quire32_t_isNaR

`quire32_t_isNaR` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_quire32_t_isNaR', self, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`quire32_t_isNaR`, 'returnType') = 'logical'
attr(`quire32_t_isNaR`, "inputTypes") = c('_p_quire32_t')
class(`quire32_t_isNaR`) = c("SWIGFunction", class('quire32_t_isNaR'))

# Start of delete_quire32_t

`delete_quire32_t` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_delete_quire32_t', self, PACKAGE='SoftPosit');

}

attr(`delete_quire32_t`, 'returnType') = 'void'
attr(`delete_quire32_t`, "inputTypes") = c('_p_quire32_t')
class(`delete_quire32_t`) = c("SWIGFunction", class('delete_quire32_t'))

# Start of accessor method for quire32_t
setMethod('$', '_p_quire32_t', function(x, name)

{
  accessorFuns = list('v' = quire32_t_v_get, 'toBits' = quire32_t_toBits, 'toHex' = quire32_t_toHex, 'clr' = quire32_t_clr, 'isNaR' = quire32_t_isNaR);
  vaccessors = c('v');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for quire32_t
# Start of accessor method for quire32_t
setMethod('$<-', '_p_quire32_t', function(x, name, value)

{
  accessorFuns = list('v' = quire32_t_v_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_quire32_t', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('v' = quire32_t_v_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for quire32_t
setMethod('delete', '_p_quire32_t', function(obj) {delete_quire32_t(obj)})
# Start definition of copy functions & methods for quire32_t
CopyToR_quire32_t = function(value, obj = new("quire32_t"))
{
  obj@v = value$v;
  obj;
}



CopyToC_quire32_t = function(value, obj)
{
  obj$v = value@v;
  obj
}



# Start definition of copy methods for quire32_t
setMethod('copyToR', '_p_quire32_t', CopyToR_quire32_t);
setMethod('copyToC', 'quire32_t', CopyToC_quire32_t);

# End definition of copy methods for quire32_t
# End definition of copy functions & methods for quire32_t
# Start of posit_2_t_v_set

`posit_2_t_v_set` = function(self, s_v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  s_v = as.integer(s_v);

  if(length(s_v) > 1) {
    warning("using only the first element of s_v");
  };

  ;.Call('R_swig_posit_2_t_v_set', self, s_v, PACKAGE='SoftPosit');

}

attr(`posit_2_t_v_set`, 'returnType') = 'void'
attr(`posit_2_t_v_set`, "inputTypes") = c('_p_posit_2_t', 'integer')
class(`posit_2_t_v_set`) = c("SWIGFunction", class('posit_2_t_v_set'))

# Start of posit_2_t_v_get

`posit_2_t_v_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_posit_2_t_v_get', self, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`posit_2_t_v_get`, 'returnType') = 'integer'
attr(`posit_2_t_v_get`, "inputTypes") = c('_p_posit_2_t')
class(`posit_2_t_v_get`) = c("SWIGFunction", class('posit_2_t_v_get'))

# Start of posit_2_t_init

`posit_2_t_init` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_posit_2_t_init', self, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`posit_2_t_init`, 'returnType') = '_p_posit_2_t'
attr(`posit_2_t_init`, "inputTypes") = c('_p_posit_2_t')
class(`posit_2_t_init`) = c("SWIGFunction", class('posit_2_t_init'))

# Start of posit_2_t_fromBits

`posit_2_t_fromBits` = function(self, bits)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  bits = as.integer(bits);

  if(length(bits) > 1) {
    warning("using only the first element of bits");
  };

  ;.Call('R_swig_posit_2_t_fromBits', self, bits, PACKAGE='SoftPosit');

}

attr(`posit_2_t_fromBits`, 'returnType') = 'void'
attr(`posit_2_t_fromBits`, "inputTypes") = c('_p_posit_2_t', 'integer')
class(`posit_2_t_fromBits`) = c("SWIGFunction", class('posit_2_t_fromBits'))

# Start of posit_2_t_toBits

`posit_2_t_toBits` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  x = as.integer(x);

  if(length(x) > 1) {
    warning("using only the first element of x");
  };

  ;.Call('R_swig_posit_2_t_toBits', self, x, PACKAGE='SoftPosit');

}

attr(`posit_2_t_toBits`, 'returnType') = 'void'
attr(`posit_2_t_toBits`, "inputTypes") = c('_p_posit_2_t', 'integer')
class(`posit_2_t_toBits`) = c("SWIGFunction", class('posit_2_t_toBits'))

# Start of posit_2_t_toHex

`posit_2_t_toHex` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  x = as.integer(x);

  if(length(x) > 1) {
    warning("using only the first element of x");
  };

  ;.Call('R_swig_posit_2_t_toHex', self, x, PACKAGE='SoftPosit');

}

attr(`posit_2_t_toHex`, 'returnType') = 'void'
attr(`posit_2_t_toHex`, "inputTypes") = c('_p_posit_2_t', 'integer')
class(`posit_2_t_toHex`) = c("SWIGFunction", class('posit_2_t_toHex'))

# Start of posit_2_t_toInt

`posit_2_t_toInt` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_posit_2_t_toInt', self, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`posit_2_t_toInt`, 'returnType') = 'integer'
attr(`posit_2_t_toInt`, "inputTypes") = c('_p_posit_2_t')
class(`posit_2_t_toInt`) = c("SWIGFunction", class('posit_2_t_toInt'))

# Start of posit_2_t_rshift

`posit_2_t_rshift` = function(self, n, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  n = as.integer(n);

  if(length(n) > 1) {
    warning("using only the first element of n");
  };

  x = as.integer(x);

  if(length(x) > 1) {
    warning("using only the first element of x");
  };

  ;ans = .Call('R_swig_posit_2_t_rshift', self, n, x, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`posit_2_t_rshift`, 'returnType') = '_p_posit_2_t'
attr(`posit_2_t_rshift`, "inputTypes") = c('_p_posit_2_t', 'integer', 'integer')
class(`posit_2_t_rshift`) = c("SWIGFunction", class('posit_2_t_rshift'))

# Start of posit_2_t_lshift

`posit_2_t_lshift` = function(self, n, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  n = as.integer(n);

  if(length(n) > 1) {
    warning("using only the first element of n");
  };

  x = as.integer(x);

  if(length(x) > 1) {
    warning("using only the first element of x");
  };

  ;ans = .Call('R_swig_posit_2_t_lshift', self, n, x, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`posit_2_t_lshift`, 'returnType') = '_p_posit_2_t'
attr(`posit_2_t_lshift`, "inputTypes") = c('_p_posit_2_t', 'integer', 'integer')
class(`posit_2_t_lshift`) = c("SWIGFunction", class('posit_2_t_lshift'))

# Start of posit_2_t_invert

`posit_2_t_invert` = function(self, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  x = as.integer(x);

  if(length(x) > 1) {
    warning("using only the first element of x");
  };

  ;ans = .Call('R_swig_posit_2_t_invert', self, x, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`posit_2_t_invert`, 'returnType') = '_p_posit_2_t'
attr(`posit_2_t_invert`, "inputTypes") = c('_p_posit_2_t', 'integer')
class(`posit_2_t_invert`) = c("SWIGFunction", class('posit_2_t_invert'))

# Start of posit_2_t_neg

`posit_2_t_neg` = function(self, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  x = as.integer(x);

  if(length(x) > 1) {
    warning("using only the first element of x");
  };

  ;ans = .Call('R_swig_posit_2_t_neg', self, x, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`posit_2_t_neg`, 'returnType') = '_p_posit_2_t'
attr(`posit_2_t_neg`, "inputTypes") = c('_p_posit_2_t', 'integer')
class(`posit_2_t_neg`) = c("SWIGFunction", class('posit_2_t_neg'))

# Start of posit_2_t_abs

`posit_2_t_abs` = function(self, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  x = as.integer(x);

  if(length(x) > 1) {
    warning("using only the first element of x");
  };

  ;ans = .Call('R_swig_posit_2_t_abs', self, x, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`posit_2_t_abs`, 'returnType') = '_p_posit_2_t'
attr(`posit_2_t_abs`, "inputTypes") = c('_p_posit_2_t', 'integer')
class(`posit_2_t_abs`) = c("SWIGFunction", class('posit_2_t_abs'))

# Start of posit_2_t_and

`posit_2_t_and` = function(self, other, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(other, "ExternalReference")) other = slot(other,"ref")
  x = as.integer(x);

  if(length(x) > 1) {
    warning("using only the first element of x");
  };

  ;ans = .Call('R_swig_posit_2_t_and', self, other, x, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`posit_2_t_and`, 'returnType') = '_p_posit_2_t'
attr(`posit_2_t_and`, "inputTypes") = c('_p_posit_2_t', '_p_posit_2_t', 'integer')
class(`posit_2_t_and`) = c("SWIGFunction", class('posit_2_t_and'))

# Start of posit_2_t_xor

`posit_2_t_xor` = function(self, other, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(other, "ExternalReference")) other = slot(other,"ref")
  x = as.integer(x);

  if(length(x) > 1) {
    warning("using only the first element of x");
  };

  ;ans = .Call('R_swig_posit_2_t_xor', self, other, x, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`posit_2_t_xor`, 'returnType') = '_p_posit_2_t'
attr(`posit_2_t_xor`, "inputTypes") = c('_p_posit_2_t', '_p_posit_2_t', 'integer')
class(`posit_2_t_xor`) = c("SWIGFunction", class('posit_2_t_xor'))

# Start of posit_2_t_or

`posit_2_t_or` = function(self, other, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(other, "ExternalReference")) other = slot(other,"ref")
  x = as.integer(x);

  if(length(x) > 1) {
    warning("using only the first element of x");
  };

  ;ans = .Call('R_swig_posit_2_t_or', self, other, x, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`posit_2_t_or`, 'returnType') = '_p_posit_2_t'
attr(`posit_2_t_or`, "inputTypes") = c('_p_posit_2_t', '_p_posit_2_t', 'integer')
class(`posit_2_t_or`) = c("SWIGFunction", class('posit_2_t_or'))

# Start of posit_2_t_isNaR

`posit_2_t_isNaR` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_posit_2_t_isNaR', self, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`posit_2_t_isNaR`, 'returnType') = 'logical'
attr(`posit_2_t_isNaR`, "inputTypes") = c('_p_posit_2_t')
class(`posit_2_t_isNaR`) = c("SWIGFunction", class('posit_2_t_isNaR'))

# Start of posit_2_t_toNaR

`posit_2_t_toNaR` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_posit_2_t_toNaR', self, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`posit_2_t_toNaR`, 'returnType') = '_p_posit_2_t'
attr(`posit_2_t_toNaR`, "inputTypes") = c('_p_posit_2_t')
class(`posit_2_t_toNaR`) = c("SWIGFunction", class('posit_2_t_toNaR'))

# Start of new_posit_2_t

`posit_2_t` = function()
{
  ;ans = .Call('R_swig_new_posit_2_t', PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans) ;

  reg.finalizer(ans@ref, delete_posit_2_t)
  ans

}

attr(`posit_2_t`, 'returnType') = '_p_posit_2_t'
class(`posit_2_t`) = c("SWIGFunction", class('posit_2_t'))

# Start of delete_posit_2_t

`delete_posit_2_t` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_delete_posit_2_t', self, PACKAGE='SoftPosit');

}

attr(`delete_posit_2_t`, 'returnType') = 'void'
attr(`delete_posit_2_t`, "inputTypes") = c('_p_posit_2_t')
class(`delete_posit_2_t`) = c("SWIGFunction", class('delete_posit_2_t'))

# Start of accessor method for posit_2_t
setMethod('$', '_p_posit_2_t', function(x, name)

{
  accessorFuns = list('v' = posit_2_t_v_get, 'init' = posit_2_t_init, 'fromBits' = posit_2_t_fromBits, 'toBits' = posit_2_t_toBits, 'toHex' = posit_2_t_toHex, 'toInt' = posit_2_t_toInt, 'rshift' = posit_2_t_rshift, 'lshift' = posit_2_t_lshift, 'invert' = posit_2_t_invert, 'neg' = posit_2_t_neg, 'abs' = posit_2_t_abs, 'and' = posit_2_t_and, 'xor' = posit_2_t_xor, 'or' = posit_2_t_or, 'isNaR' = posit_2_t_isNaR, 'toNaR' = posit_2_t_toNaR);
  vaccessors = c('v');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for posit_2_t
# Start of accessor method for posit_2_t
setMethod('$<-', '_p_posit_2_t', function(x, name, value)

{
  accessorFuns = list('v' = posit_2_t_v_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_posit_2_t', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('v' = posit_2_t_v_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for posit_2_t
setMethod('delete', '_p_posit_2_t', function(obj) {delete_posit_2_t(obj)})
# Start definition of copy functions & methods for posit_2_t
CopyToR_posit_2_t = function(value, obj = new("posit_2_t"))
{
  obj@v = value$v;
  obj;
}



CopyToC_posit_2_t = function(value, obj)
{
  obj$v = value@v;
  obj
}



# Start definition of copy methods for posit_2_t
setMethod('copyToR', '_p_posit_2_t', CopyToR_posit_2_t);
setMethod('copyToC', 'posit_2_t', CopyToC_posit_2_t);

# End definition of copy methods for posit_2_t
# End definition of copy functions & methods for posit_2_t
# Start of quire_2_t_v_set

`quire_2_t_v_set` = function(self, s_v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  s_v = as.integer(s_v);

  #  assert(length(s_v) >= 8)

  ;.Call('R_swig_quire_2_t_v_set', self, s_v, PACKAGE='SoftPosit');

}

attr(`quire_2_t_v_set`, 'returnType') = 'void'
attr(`quire_2_t_v_set`, "inputTypes") = c('_p_quire_2_t', 'integer')
class(`quire_2_t_v_set`) = c("SWIGFunction", class('quire_2_t_v_set'))

# Start of quire_2_t_v_get

`quire_2_t_v_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_quire_2_t_v_get', self, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_unsigned_long_long", ref=ans) ;

  ans

}

attr(`quire_2_t_v_get`, 'returnType') = 'integer'
attr(`quire_2_t_v_get`, "inputTypes") = c('_p_quire_2_t')
class(`quire_2_t_v_get`) = c("SWIGFunction", class('quire_2_t_v_get'))

# Start of new_quire_2_t

`quire_2_t` = function()
{
  ;ans = .Call('R_swig_new_quire_2_t', PACKAGE='SoftPosit');
  ans <- new("_p_quire_2_t", ref=ans) ;

  reg.finalizer(ans@ref, delete_quire_2_t)
  ans

}

attr(`quire_2_t`, 'returnType') = '_p_quire_2_t'
class(`quire_2_t`) = c("SWIGFunction", class('quire_2_t'))

# Start of quire_2_t_toBits

`quire_2_t_toBits` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_quire_2_t_toBits', self, PACKAGE='SoftPosit');

}

attr(`quire_2_t_toBits`, 'returnType') = 'void'
attr(`quire_2_t_toBits`, "inputTypes") = c('_p_quire_2_t')
class(`quire_2_t_toBits`) = c("SWIGFunction", class('quire_2_t_toBits'))

# Start of quire_2_t_toHex

`quire_2_t_toHex` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_quire_2_t_toHex', self, PACKAGE='SoftPosit');

}

attr(`quire_2_t_toHex`, 'returnType') = 'void'
attr(`quire_2_t_toHex`, "inputTypes") = c('_p_quire_2_t')
class(`quire_2_t_toHex`) = c("SWIGFunction", class('quire_2_t_toHex'))

# Start of quire_2_t_clr

`quire_2_t_clr` = function(self, q, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(q, "ExternalReference")) q = slot(q,"ref")
  ;ans = .Call('R_swig_quire_2_t_clr', self, q, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_quire_2_t", ref=ans);

  ans

}

attr(`quire_2_t_clr`, 'returnType') = '_p_quire_2_t'
attr(`quire_2_t_clr`, "inputTypes") = c('_p_quire_2_t', '_p_quire_2_t')
class(`quire_2_t_clr`) = c("SWIGFunction", class('quire_2_t_clr'))

# Start of quire_2_t_isNaR

`quire_2_t_isNaR` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_quire_2_t_isNaR', self, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`quire_2_t_isNaR`, 'returnType') = 'logical'
attr(`quire_2_t_isNaR`, "inputTypes") = c('_p_quire_2_t')
class(`quire_2_t_isNaR`) = c("SWIGFunction", class('quire_2_t_isNaR'))

# Start of delete_quire_2_t

`delete_quire_2_t` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_delete_quire_2_t', self, PACKAGE='SoftPosit');

}

attr(`delete_quire_2_t`, 'returnType') = 'void'
attr(`delete_quire_2_t`, "inputTypes") = c('_p_quire_2_t')
class(`delete_quire_2_t`) = c("SWIGFunction", class('delete_quire_2_t'))

# Start of accessor method for quire_2_t
setMethod('$', '_p_quire_2_t', function(x, name)

{
  accessorFuns = list('v' = quire_2_t_v_get, 'toBits' = quire_2_t_toBits, 'toHex' = quire_2_t_toHex, 'clr' = quire_2_t_clr, 'isNaR' = quire_2_t_isNaR);
  vaccessors = c('v');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for quire_2_t
# Start of accessor method for quire_2_t
setMethod('$<-', '_p_quire_2_t', function(x, name, value)

{
  accessorFuns = list('v' = quire_2_t_v_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_quire_2_t', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('v' = quire_2_t_v_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for quire_2_t
setMethod('delete', '_p_quire_2_t', function(obj) {delete_quire_2_t(obj)})
# Start definition of copy functions & methods for quire_2_t
CopyToR_quire_2_t = function(value, obj = new("quire_2_t"))
{
  obj@v = value$v;
  obj;
}



CopyToC_quire_2_t = function(value, obj)
{
  obj$v = value@v;
  obj
}



# Start definition of copy methods for quire_2_t
setMethod('copyToR', '_p_quire_2_t', CopyToR_quire_2_t);
setMethod('copyToC', 'quire_2_t', CopyToC_quire_2_t);

# End definition of copy methods for quire_2_t
# End definition of copy functions & methods for quire_2_t
# Start of ui8_p8_ui_set

`ui8_p8_ui_set` = function(self, s_ui)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  s_ui = as.integer(s_ui);

  if(length(s_ui) > 1) {
    warning("using only the first element of s_ui");
  };

  ;.Call('R_swig_ui8_p8_ui_set', self, s_ui, PACKAGE='SoftPosit');

}

attr(`ui8_p8_ui_set`, 'returnType') = 'void'
attr(`ui8_p8_ui_set`, "inputTypes") = c('_p_ui8_p8', 'integer')
class(`ui8_p8_ui_set`) = c("SWIGFunction", class('ui8_p8_ui_set'))

# Start of ui8_p8_ui_get

`ui8_p8_ui_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_ui8_p8_ui_get', self, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`ui8_p8_ui_get`, 'returnType') = 'integer'
attr(`ui8_p8_ui_get`, "inputTypes") = c('_p_ui8_p8')
class(`ui8_p8_ui_get`) = c("SWIGFunction", class('ui8_p8_ui_get'))

# Start of ui8_p8_p_set

`ui8_p8_p_set` = function(self, s_p)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(s_p, "ExternalReference")) s_p = slot(s_p,"ref")
  ;.Call('R_swig_ui8_p8_p_set', self, s_p, PACKAGE='SoftPosit');

}

attr(`ui8_p8_p_set`, 'returnType') = 'void'
attr(`ui8_p8_p_set`, "inputTypes") = c('_p_ui8_p8', '_p_posit8_t')
class(`ui8_p8_p_set`) = c("SWIGFunction", class('ui8_p8_p_set'))

# Start of ui8_p8_p_get

`ui8_p8_p_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_ui8_p8_p_get', self, PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans) ;

  ans

}

attr(`ui8_p8_p_get`, 'returnType') = '_p_posit8_t'
attr(`ui8_p8_p_get`, "inputTypes") = c('_p_ui8_p8')
class(`ui8_p8_p_get`) = c("SWIGFunction", class('ui8_p8_p_get'))

# Start of new_ui8_p8

`ui8_p8` = function()
{
  ;ans = .Call('R_swig_new_ui8_p8', PACKAGE='SoftPosit');
  ans <- new("_p_ui8_p8", ref=ans) ;

  reg.finalizer(ans@ref, delete_ui8_p8)
  ans

}

attr(`ui8_p8`, 'returnType') = '_p_ui8_p8'
class(`ui8_p8`) = c("SWIGFunction", class('ui8_p8'))

# Start of delete_ui8_p8

`delete_ui8_p8` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_delete_ui8_p8', self, PACKAGE='SoftPosit');

}

attr(`delete_ui8_p8`, 'returnType') = 'void'
attr(`delete_ui8_p8`, "inputTypes") = c('_p_ui8_p8')
class(`delete_ui8_p8`) = c("SWIGFunction", class('delete_ui8_p8'))

# Start of accessor method for ui8_p8
setMethod('$', '_p_ui8_p8', function(x, name)

{
  accessorFuns = list('ui' = ui8_p8_ui_get, 'p' = ui8_p8_p_get);
  vaccessors = c('ui', 'p');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for ui8_p8
# Start of accessor method for ui8_p8
setMethod('$<-', '_p_ui8_p8', function(x, name, value)

{
  accessorFuns = list('ui' = ui8_p8_ui_set, 'p' = ui8_p8_p_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_ui8_p8', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('ui' = ui8_p8_ui_set, 'p' = ui8_p8_p_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for ui8_p8
setMethod('delete', '_p_ui8_p8', function(obj) {delete_ui8_p8(obj)})
# Start of ui16_p16_ui_set

`ui16_p16_ui_set` = function(self, s_ui)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  s_ui = as.integer(s_ui);

  if(length(s_ui) > 1) {
    warning("using only the first element of s_ui");
  };

  ;.Call('R_swig_ui16_p16_ui_set', self, s_ui, PACKAGE='SoftPosit');

}

attr(`ui16_p16_ui_set`, 'returnType') = 'void'
attr(`ui16_p16_ui_set`, "inputTypes") = c('_p_ui16_p16', 'integer')
class(`ui16_p16_ui_set`) = c("SWIGFunction", class('ui16_p16_ui_set'))

# Start of ui16_p16_ui_get

`ui16_p16_ui_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_ui16_p16_ui_get', self, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`ui16_p16_ui_get`, 'returnType') = 'integer'
attr(`ui16_p16_ui_get`, "inputTypes") = c('_p_ui16_p16')
class(`ui16_p16_ui_get`) = c("SWIGFunction", class('ui16_p16_ui_get'))

# Start of ui16_p16_p_set

`ui16_p16_p_set` = function(self, s_p)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(s_p, "ExternalReference")) s_p = slot(s_p,"ref")
  ;.Call('R_swig_ui16_p16_p_set', self, s_p, PACKAGE='SoftPosit');

}

attr(`ui16_p16_p_set`, 'returnType') = 'void'
attr(`ui16_p16_p_set`, "inputTypes") = c('_p_ui16_p16', '_p_posit16_t')
class(`ui16_p16_p_set`) = c("SWIGFunction", class('ui16_p16_p_set'))

# Start of ui16_p16_p_get

`ui16_p16_p_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_ui16_p16_p_get', self, PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans) ;

  ans

}

attr(`ui16_p16_p_get`, 'returnType') = '_p_posit16_t'
attr(`ui16_p16_p_get`, "inputTypes") = c('_p_ui16_p16')
class(`ui16_p16_p_get`) = c("SWIGFunction", class('ui16_p16_p_get'))

# Start of new_ui16_p16

`ui16_p16` = function()
{
  ;ans = .Call('R_swig_new_ui16_p16', PACKAGE='SoftPosit');
  ans <- new("_p_ui16_p16", ref=ans) ;

  reg.finalizer(ans@ref, delete_ui16_p16)
  ans

}

attr(`ui16_p16`, 'returnType') = '_p_ui16_p16'
class(`ui16_p16`) = c("SWIGFunction", class('ui16_p16'))

# Start of delete_ui16_p16

`delete_ui16_p16` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_delete_ui16_p16', self, PACKAGE='SoftPosit');

}

attr(`delete_ui16_p16`, 'returnType') = 'void'
attr(`delete_ui16_p16`, "inputTypes") = c('_p_ui16_p16')
class(`delete_ui16_p16`) = c("SWIGFunction", class('delete_ui16_p16'))

# Start of accessor method for ui16_p16
setMethod('$', '_p_ui16_p16', function(x, name)

{
  accessorFuns = list('ui' = ui16_p16_ui_get, 'p' = ui16_p16_p_get);
  vaccessors = c('ui', 'p');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for ui16_p16
# Start of accessor method for ui16_p16
setMethod('$<-', '_p_ui16_p16', function(x, name, value)

{
  accessorFuns = list('ui' = ui16_p16_ui_set, 'p' = ui16_p16_p_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_ui16_p16', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('ui' = ui16_p16_ui_set, 'p' = ui16_p16_p_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for ui16_p16
setMethod('delete', '_p_ui16_p16', function(obj) {delete_ui16_p16(obj)})
# Start of ui32_p32_ui_set

`ui32_p32_ui_set` = function(self, s_ui)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  s_ui = as.integer(s_ui);

  if(length(s_ui) > 1) {
    warning("using only the first element of s_ui");
  };

  ;.Call('R_swig_ui32_p32_ui_set', self, s_ui, PACKAGE='SoftPosit');

}

attr(`ui32_p32_ui_set`, 'returnType') = 'void'
attr(`ui32_p32_ui_set`, "inputTypes") = c('_p_ui32_p32', 'integer')
class(`ui32_p32_ui_set`) = c("SWIGFunction", class('ui32_p32_ui_set'))

# Start of ui32_p32_ui_get

`ui32_p32_ui_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_ui32_p32_ui_get', self, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`ui32_p32_ui_get`, 'returnType') = 'integer'
attr(`ui32_p32_ui_get`, "inputTypes") = c('_p_ui32_p32')
class(`ui32_p32_ui_get`) = c("SWIGFunction", class('ui32_p32_ui_get'))

# Start of ui32_p32_p_set

`ui32_p32_p_set` = function(self, s_p)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(s_p, "ExternalReference")) s_p = slot(s_p,"ref")
  ;.Call('R_swig_ui32_p32_p_set', self, s_p, PACKAGE='SoftPosit');

}

attr(`ui32_p32_p_set`, 'returnType') = 'void'
attr(`ui32_p32_p_set`, "inputTypes") = c('_p_ui32_p32', '_p_posit32_t')
class(`ui32_p32_p_set`) = c("SWIGFunction", class('ui32_p32_p_set'))

# Start of ui32_p32_p_get

`ui32_p32_p_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_ui32_p32_p_get', self, PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans) ;

  ans

}

attr(`ui32_p32_p_get`, 'returnType') = '_p_posit32_t'
attr(`ui32_p32_p_get`, "inputTypes") = c('_p_ui32_p32')
class(`ui32_p32_p_get`) = c("SWIGFunction", class('ui32_p32_p_get'))

# Start of new_ui32_p32

`ui32_p32` = function()
{
  ;ans = .Call('R_swig_new_ui32_p32', PACKAGE='SoftPosit');
  ans <- new("_p_ui32_p32", ref=ans) ;

  reg.finalizer(ans@ref, delete_ui32_p32)
  ans

}

attr(`ui32_p32`, 'returnType') = '_p_ui32_p32'
class(`ui32_p32`) = c("SWIGFunction", class('ui32_p32'))

# Start of delete_ui32_p32

`delete_ui32_p32` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_delete_ui32_p32', self, PACKAGE='SoftPosit');

}

attr(`delete_ui32_p32`, 'returnType') = 'void'
attr(`delete_ui32_p32`, "inputTypes") = c('_p_ui32_p32')
class(`delete_ui32_p32`) = c("SWIGFunction", class('delete_ui32_p32'))

# Start of accessor method for ui32_p32
setMethod('$', '_p_ui32_p32', function(x, name)

{
  accessorFuns = list('ui' = ui32_p32_ui_get, 'p' = ui32_p32_p_get);
  vaccessors = c('ui', 'p');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for ui32_p32
# Start of accessor method for ui32_p32
setMethod('$<-', '_p_ui32_p32', function(x, name, value)

{
  accessorFuns = list('ui' = ui32_p32_ui_set, 'p' = ui32_p32_p_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_ui32_p32', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('ui' = ui32_p32_ui_set, 'p' = ui32_p32_p_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for ui32_p32
setMethod('delete', '_p_ui32_p32', function(obj) {delete_ui32_p32(obj)})
# Start of ui64_p64_ui_set

`ui64_p64_ui_set` = function(self, s_ui)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  s_ui = as.integer(s_ui);

  if(length(s_ui) > 1) {
    warning("using only the first element of s_ui");
  };

  ;.Call('R_swig_ui64_p64_ui_set', self, s_ui, PACKAGE='SoftPosit');

}

attr(`ui64_p64_ui_set`, 'returnType') = 'void'
attr(`ui64_p64_ui_set`, "inputTypes") = c('_p_ui64_p64', 'integer')
class(`ui64_p64_ui_set`) = c("SWIGFunction", class('ui64_p64_ui_set'))

# Start of ui64_p64_ui_get

`ui64_p64_ui_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_ui64_p64_ui_get', self, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`ui64_p64_ui_get`, 'returnType') = 'integer'
attr(`ui64_p64_ui_get`, "inputTypes") = c('_p_ui64_p64')
class(`ui64_p64_ui_get`) = c("SWIGFunction", class('ui64_p64_ui_get'))

# Start of ui64_p64_p_set

`ui64_p64_p_set` = function(self, s_p)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(s_p, "ExternalReference")) s_p = slot(s_p,"ref")
  ;.Call('R_swig_ui64_p64_p_set', self, s_p, PACKAGE='SoftPosit');

}

attr(`ui64_p64_p_set`, 'returnType') = 'void'
attr(`ui64_p64_p_set`, "inputTypes") = c('_p_ui64_p64', '_p_posit64_t')
class(`ui64_p64_p_set`) = c("SWIGFunction", class('ui64_p64_p_set'))

# Start of ui64_p64_p_get

`ui64_p64_p_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_ui64_p64_p_get', self, PACKAGE='SoftPosit');
  ans <- new("_p_posit64_t", ref=ans) ;

  ans

}

attr(`ui64_p64_p_get`, 'returnType') = '_p_posit64_t'
attr(`ui64_p64_p_get`, "inputTypes") = c('_p_ui64_p64')
class(`ui64_p64_p_get`) = c("SWIGFunction", class('ui64_p64_p_get'))

# Start of new_ui64_p64

`ui64_p64` = function()
{
  ;ans = .Call('R_swig_new_ui64_p64', PACKAGE='SoftPosit');
  ans <- new("_p_ui64_p64", ref=ans) ;

  reg.finalizer(ans@ref, delete_ui64_p64)
  ans

}

attr(`ui64_p64`, 'returnType') = '_p_ui64_p64'
class(`ui64_p64`) = c("SWIGFunction", class('ui64_p64'))

# Start of delete_ui64_p64

`delete_ui64_p64` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_delete_ui64_p64', self, PACKAGE='SoftPosit');

}

attr(`delete_ui64_p64`, 'returnType') = 'void'
attr(`delete_ui64_p64`, "inputTypes") = c('_p_ui64_p64')
class(`delete_ui64_p64`) = c("SWIGFunction", class('delete_ui64_p64'))

# Start of accessor method for ui64_p64
setMethod('$', '_p_ui64_p64', function(x, name)

{
  accessorFuns = list('ui' = ui64_p64_ui_get, 'p' = ui64_p64_p_get);
  vaccessors = c('ui', 'p');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for ui64_p64
# Start of accessor method for ui64_p64
setMethod('$<-', '_p_ui64_p64', function(x, name, value)

{
  accessorFuns = list('ui' = ui64_p64_ui_set, 'p' = ui64_p64_p_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_ui64_p64', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('ui' = ui64_p64_ui_set, 'p' = ui64_p64_p_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for ui64_p64
setMethod('delete', '_p_ui64_p64', function(obj) {delete_ui64_p64(obj)})
# Start of ui128_p128c_ui_set

`ui128_p128c_ui_set` = function(self, s_ui)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  s_ui = as.integer(s_ui);

  #  assert(length(s_ui) >= 2)

  ;.Call('R_swig_ui128_p128c_ui_set', self, s_ui, PACKAGE='SoftPosit');

}

attr(`ui128_p128c_ui_set`, 'returnType') = 'void'
attr(`ui128_p128c_ui_set`, "inputTypes") = c('_p_ui128_p128c', 'integer')
class(`ui128_p128c_ui_set`) = c("SWIGFunction", class('ui128_p128c_ui_set'))

# Start of ui128_p128c_ui_get

`ui128_p128c_ui_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_ui128_p128c_ui_get', self, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_unsigned_long_long", ref=ans) ;

  ans

}

attr(`ui128_p128c_ui_get`, 'returnType') = 'integer'
attr(`ui128_p128c_ui_get`, "inputTypes") = c('_p_ui128_p128c')
class(`ui128_p128c_ui_get`) = c("SWIGFunction", class('ui128_p128c_ui_get'))

# Start of ui128_p128c_p_set

`ui128_p128c_p_set` = function(self, s_p)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(s_p, "ExternalReference")) s_p = slot(s_p,"ref")
  ;.Call('R_swig_ui128_p128c_p_set', self, s_p, PACKAGE='SoftPosit');

}

attr(`ui128_p128c_p_set`, 'returnType') = 'void'
attr(`ui128_p128c_p_set`, "inputTypes") = c('_p_ui128_p128c', '_p_posit128_t')
class(`ui128_p128c_p_set`) = c("SWIGFunction", class('ui128_p128c_p_set'))

# Start of ui128_p128c_p_get

`ui128_p128c_p_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_ui128_p128c_p_get', self, PACKAGE='SoftPosit');
  ans <- new("_p_posit128_t", ref=ans) ;

  ans

}

attr(`ui128_p128c_p_get`, 'returnType') = '_p_posit128_t'
attr(`ui128_p128c_p_get`, "inputTypes") = c('_p_ui128_p128c')
class(`ui128_p128c_p_get`) = c("SWIGFunction", class('ui128_p128c_p_get'))

# Start of new_ui128_p128c

`ui128_p128c` = function()
{
  ;ans = .Call('R_swig_new_ui128_p128c', PACKAGE='SoftPosit');
  ans <- new("_p_ui128_p128c", ref=ans) ;

  reg.finalizer(ans@ref, delete_ui128_p128c)
  ans

}

attr(`ui128_p128c`, 'returnType') = '_p_ui128_p128c'
class(`ui128_p128c`) = c("SWIGFunction", class('ui128_p128c'))

# Start of delete_ui128_p128c

`delete_ui128_p128c` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_delete_ui128_p128c', self, PACKAGE='SoftPosit');

}

attr(`delete_ui128_p128c`, 'returnType') = 'void'
attr(`delete_ui128_p128c`, "inputTypes") = c('_p_ui128_p128c')
class(`delete_ui128_p128c`) = c("SWIGFunction", class('delete_ui128_p128c'))

# Start of accessor method for ui128_p128c
setMethod('$', '_p_ui128_p128c', function(x, name)

{
  accessorFuns = list('ui' = ui128_p128c_ui_get, 'p' = ui128_p128c_p_get);
  vaccessors = c('ui', 'p');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for ui128_p128c
# Start of accessor method for ui128_p128c
setMethod('$<-', '_p_ui128_p128c', function(x, name, value)

{
  accessorFuns = list('ui' = ui128_p128c_ui_set, 'p' = ui128_p128c_p_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_ui128_p128c', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('ui' = ui128_p128c_ui_set, 'p' = ui128_p128c_p_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for ui128_p128c
setMethod('delete', '_p_ui128_p128c', function(obj) {delete_ui128_p128c(obj)})
# Start of ui32_pX2_ui_set

`ui32_pX2_ui_set` = function(self, s_ui)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  s_ui = as.integer(s_ui);

  if(length(s_ui) > 1) {
    warning("using only the first element of s_ui");
  };

  ;.Call('R_swig_ui32_pX2_ui_set', self, s_ui, PACKAGE='SoftPosit');

}

attr(`ui32_pX2_ui_set`, 'returnType') = 'void'
attr(`ui32_pX2_ui_set`, "inputTypes") = c('_p_ui32_pX2', 'integer')
class(`ui32_pX2_ui_set`) = c("SWIGFunction", class('ui32_pX2_ui_set'))

# Start of ui32_pX2_ui_get

`ui32_pX2_ui_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_ui32_pX2_ui_get', self, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`ui32_pX2_ui_get`, 'returnType') = 'integer'
attr(`ui32_pX2_ui_get`, "inputTypes") = c('_p_ui32_pX2')
class(`ui32_pX2_ui_get`) = c("SWIGFunction", class('ui32_pX2_ui_get'))

# Start of ui32_pX2_p_set

`ui32_pX2_p_set` = function(self, s_p)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(s_p, "ExternalReference")) s_p = slot(s_p,"ref")
  ;.Call('R_swig_ui32_pX2_p_set', self, s_p, PACKAGE='SoftPosit');

}

attr(`ui32_pX2_p_set`, 'returnType') = 'void'
attr(`ui32_pX2_p_set`, "inputTypes") = c('_p_ui32_pX2', '_p_posit_2_t')
class(`ui32_pX2_p_set`) = c("SWIGFunction", class('ui32_pX2_p_set'))

# Start of ui32_pX2_p_get

`ui32_pX2_p_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_ui32_pX2_p_get', self, PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans) ;

  ans

}

attr(`ui32_pX2_p_get`, 'returnType') = '_p_posit_2_t'
attr(`ui32_pX2_p_get`, "inputTypes") = c('_p_ui32_pX2')
class(`ui32_pX2_p_get`) = c("SWIGFunction", class('ui32_pX2_p_get'))

# Start of new_ui32_pX2

`ui32_pX2` = function()
{
  ;ans = .Call('R_swig_new_ui32_pX2', PACKAGE='SoftPosit');
  ans <- new("_p_ui32_pX2", ref=ans) ;

  reg.finalizer(ans@ref, delete_ui32_pX2)
  ans

}

attr(`ui32_pX2`, 'returnType') = '_p_ui32_pX2'
class(`ui32_pX2`) = c("SWIGFunction", class('ui32_pX2'))

# Start of delete_ui32_pX2

`delete_ui32_pX2` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_delete_ui32_pX2', self, PACKAGE='SoftPosit');

}

attr(`delete_ui32_pX2`, 'returnType') = 'void'
attr(`delete_ui32_pX2`, "inputTypes") = c('_p_ui32_pX2')
class(`delete_ui32_pX2`) = c("SWIGFunction", class('delete_ui32_pX2'))

# Start of accessor method for ui32_pX2
setMethod('$', '_p_ui32_pX2', function(x, name)

{
  accessorFuns = list('ui' = ui32_pX2_ui_get, 'p' = ui32_pX2_p_get);
  vaccessors = c('ui', 'p');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for ui32_pX2
# Start of accessor method for ui32_pX2
setMethod('$<-', '_p_ui32_pX2', function(x, name, value)

{
  accessorFuns = list('ui' = ui32_pX2_ui_set, 'p' = ui32_pX2_p_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_ui32_pX2', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('ui' = ui32_pX2_ui_set, 'p' = ui32_pX2_p_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for ui32_pX2
setMethod('delete', '_p_ui32_pX2', function(obj) {delete_ui32_pX2(obj)})
# Start of ui32_q8_ui_set

`ui32_q8_ui_set` = function(self, s_ui)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  s_ui = as.integer(s_ui);

  if(length(s_ui) > 1) {
    warning("using only the first element of s_ui");
  };

  ;.Call('R_swig_ui32_q8_ui_set', self, s_ui, PACKAGE='SoftPosit');

}

attr(`ui32_q8_ui_set`, 'returnType') = 'void'
attr(`ui32_q8_ui_set`, "inputTypes") = c('_p_ui32_q8', 'integer')
class(`ui32_q8_ui_set`) = c("SWIGFunction", class('ui32_q8_ui_set'))

# Start of ui32_q8_ui_get

`ui32_q8_ui_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_ui32_q8_ui_get', self, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`ui32_q8_ui_get`, 'returnType') = 'integer'
attr(`ui32_q8_ui_get`, "inputTypes") = c('_p_ui32_q8')
class(`ui32_q8_ui_get`) = c("SWIGFunction", class('ui32_q8_ui_get'))

# Start of ui32_q8_q_set

`ui32_q8_q_set` = function(self, s_q)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(s_q, "ExternalReference")) s_q = slot(s_q,"ref")
  ;.Call('R_swig_ui32_q8_q_set', self, s_q, PACKAGE='SoftPosit');

}

attr(`ui32_q8_q_set`, 'returnType') = 'void'
attr(`ui32_q8_q_set`, "inputTypes") = c('_p_ui32_q8', '_p_quire8_t')
class(`ui32_q8_q_set`) = c("SWIGFunction", class('ui32_q8_q_set'))

# Start of ui32_q8_q_get

`ui32_q8_q_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_ui32_q8_q_get', self, PACKAGE='SoftPosit');
  ans <- new("_p_quire8_t", ref=ans) ;

  ans

}

attr(`ui32_q8_q_get`, 'returnType') = '_p_quire8_t'
attr(`ui32_q8_q_get`, "inputTypes") = c('_p_ui32_q8')
class(`ui32_q8_q_get`) = c("SWIGFunction", class('ui32_q8_q_get'))

# Start of new_ui32_q8

`ui32_q8` = function()
{
  ;ans = .Call('R_swig_new_ui32_q8', PACKAGE='SoftPosit');
  ans <- new("_p_ui32_q8", ref=ans) ;

  reg.finalizer(ans@ref, delete_ui32_q8)
  ans

}

attr(`ui32_q8`, 'returnType') = '_p_ui32_q8'
class(`ui32_q8`) = c("SWIGFunction", class('ui32_q8'))

# Start of delete_ui32_q8

`delete_ui32_q8` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_delete_ui32_q8', self, PACKAGE='SoftPosit');

}

attr(`delete_ui32_q8`, 'returnType') = 'void'
attr(`delete_ui32_q8`, "inputTypes") = c('_p_ui32_q8')
class(`delete_ui32_q8`) = c("SWIGFunction", class('delete_ui32_q8'))

# Start of accessor method for ui32_q8
setMethod('$', '_p_ui32_q8', function(x, name)

{
  accessorFuns = list('ui' = ui32_q8_ui_get, 'q' = ui32_q8_q_get);
  vaccessors = c('ui', 'q');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for ui32_q8
# Start of accessor method for ui32_q8
setMethod('$<-', '_p_ui32_q8', function(x, name, value)

{
  accessorFuns = list('ui' = ui32_q8_ui_set, 'q' = ui32_q8_q_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_ui32_q8', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('ui' = ui32_q8_ui_set, 'q' = ui32_q8_q_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for ui32_q8
setMethod('delete', '_p_ui32_q8', function(obj) {delete_ui32_q8(obj)})
# Start of ui128_q16_ui_set

`ui128_q16_ui_set` = function(self, s_ui)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  s_ui = as.integer(s_ui);

  #  assert(length(s_ui) >= 2)

  ;.Call('R_swig_ui128_q16_ui_set', self, s_ui, PACKAGE='SoftPosit');

}

attr(`ui128_q16_ui_set`, 'returnType') = 'void'
attr(`ui128_q16_ui_set`, "inputTypes") = c('_p_ui128_q16', 'integer')
class(`ui128_q16_ui_set`) = c("SWIGFunction", class('ui128_q16_ui_set'))

# Start of ui128_q16_ui_get

`ui128_q16_ui_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_ui128_q16_ui_get', self, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_unsigned_long_long", ref=ans) ;

  ans

}

attr(`ui128_q16_ui_get`, 'returnType') = 'integer'
attr(`ui128_q16_ui_get`, "inputTypes") = c('_p_ui128_q16')
class(`ui128_q16_ui_get`) = c("SWIGFunction", class('ui128_q16_ui_get'))

# Start of ui128_q16_q_set

`ui128_q16_q_set` = function(self, s_q)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(s_q, "ExternalReference")) s_q = slot(s_q,"ref")
  ;.Call('R_swig_ui128_q16_q_set', self, s_q, PACKAGE='SoftPosit');

}

attr(`ui128_q16_q_set`, 'returnType') = 'void'
attr(`ui128_q16_q_set`, "inputTypes") = c('_p_ui128_q16', '_p_quire16_t')
class(`ui128_q16_q_set`) = c("SWIGFunction", class('ui128_q16_q_set'))

# Start of ui128_q16_q_get

`ui128_q16_q_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_ui128_q16_q_get', self, PACKAGE='SoftPosit');
  ans <- new("_p_quire16_t", ref=ans) ;

  ans

}

attr(`ui128_q16_q_get`, 'returnType') = '_p_quire16_t'
attr(`ui128_q16_q_get`, "inputTypes") = c('_p_ui128_q16')
class(`ui128_q16_q_get`) = c("SWIGFunction", class('ui128_q16_q_get'))

# Start of new_ui128_q16

`ui128_q16` = function()
{
  ;ans = .Call('R_swig_new_ui128_q16', PACKAGE='SoftPosit');
  ans <- new("_p_ui128_q16", ref=ans) ;

  reg.finalizer(ans@ref, delete_ui128_q16)
  ans

}

attr(`ui128_q16`, 'returnType') = '_p_ui128_q16'
class(`ui128_q16`) = c("SWIGFunction", class('ui128_q16'))

# Start of delete_ui128_q16

`delete_ui128_q16` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_delete_ui128_q16', self, PACKAGE='SoftPosit');

}

attr(`delete_ui128_q16`, 'returnType') = 'void'
attr(`delete_ui128_q16`, "inputTypes") = c('_p_ui128_q16')
class(`delete_ui128_q16`) = c("SWIGFunction", class('delete_ui128_q16'))

# Start of accessor method for ui128_q16
setMethod('$', '_p_ui128_q16', function(x, name)

{
  accessorFuns = list('ui' = ui128_q16_ui_get, 'q' = ui128_q16_q_get);
  vaccessors = c('ui', 'q');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for ui128_q16
# Start of accessor method for ui128_q16
setMethod('$<-', '_p_ui128_q16', function(x, name, value)

{
  accessorFuns = list('ui' = ui128_q16_ui_set, 'q' = ui128_q16_q_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_ui128_q16', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('ui' = ui128_q16_ui_set, 'q' = ui128_q16_q_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for ui128_q16
setMethod('delete', '_p_ui128_q16', function(obj) {delete_ui128_q16(obj)})
# Start of ui512_q32_ui_set

`ui512_q32_ui_set` = function(self, s_ui)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  s_ui = as.integer(s_ui);

  #  assert(length(s_ui) >= 8)

  ;.Call('R_swig_ui512_q32_ui_set', self, s_ui, PACKAGE='SoftPosit');

}

attr(`ui512_q32_ui_set`, 'returnType') = 'void'
attr(`ui512_q32_ui_set`, "inputTypes") = c('_p_ui512_q32', 'integer')
class(`ui512_q32_ui_set`) = c("SWIGFunction", class('ui512_q32_ui_set'))

# Start of ui512_q32_ui_get

`ui512_q32_ui_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_ui512_q32_ui_get', self, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_unsigned_long_long", ref=ans) ;

  ans

}

attr(`ui512_q32_ui_get`, 'returnType') = 'integer'
attr(`ui512_q32_ui_get`, "inputTypes") = c('_p_ui512_q32')
class(`ui512_q32_ui_get`) = c("SWIGFunction", class('ui512_q32_ui_get'))

# Start of ui512_q32_q_set

`ui512_q32_q_set` = function(self, s_q)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(s_q, "ExternalReference")) s_q = slot(s_q,"ref")
  ;.Call('R_swig_ui512_q32_q_set', self, s_q, PACKAGE='SoftPosit');

}

attr(`ui512_q32_q_set`, 'returnType') = 'void'
attr(`ui512_q32_q_set`, "inputTypes") = c('_p_ui512_q32', '_p_quire32_t')
class(`ui512_q32_q_set`) = c("SWIGFunction", class('ui512_q32_q_set'))

# Start of ui512_q32_q_get

`ui512_q32_q_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_ui512_q32_q_get', self, PACKAGE='SoftPosit');
  ans <- new("_p_quire32_t", ref=ans) ;

  ans

}

attr(`ui512_q32_q_get`, 'returnType') = '_p_quire32_t'
attr(`ui512_q32_q_get`, "inputTypes") = c('_p_ui512_q32')
class(`ui512_q32_q_get`) = c("SWIGFunction", class('ui512_q32_q_get'))

# Start of new_ui512_q32

`ui512_q32` = function()
{
  ;ans = .Call('R_swig_new_ui512_q32', PACKAGE='SoftPosit');
  ans <- new("_p_ui512_q32", ref=ans) ;

  reg.finalizer(ans@ref, delete_ui512_q32)
  ans

}

attr(`ui512_q32`, 'returnType') = '_p_ui512_q32'
class(`ui512_q32`) = c("SWIGFunction", class('ui512_q32'))

# Start of delete_ui512_q32

`delete_ui512_q32` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_delete_ui512_q32', self, PACKAGE='SoftPosit');

}

attr(`delete_ui512_q32`, 'returnType') = 'void'
attr(`delete_ui512_q32`, "inputTypes") = c('_p_ui512_q32')
class(`delete_ui512_q32`) = c("SWIGFunction", class('delete_ui512_q32'))

# Start of accessor method for ui512_q32
setMethod('$', '_p_ui512_q32', function(x, name)

{
  accessorFuns = list('ui' = ui512_q32_ui_get, 'q' = ui512_q32_q_get);
  vaccessors = c('ui', 'q');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for ui512_q32
# Start of accessor method for ui512_q32
setMethod('$<-', '_p_ui512_q32', function(x, name, value)

{
  accessorFuns = list('ui' = ui512_q32_ui_set, 'q' = ui512_q32_q_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_ui512_q32', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('ui' = ui512_q32_ui_set, 'q' = ui512_q32_q_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for ui512_q32
setMethod('delete', '_p_ui512_q32', function(obj) {delete_ui512_q32(obj)})
# Start of ui512_qX2_ui_set

`ui512_qX2_ui_set` = function(self, s_ui)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  s_ui = as.integer(s_ui);

  #  assert(length(s_ui) >= 8)

  ;.Call('R_swig_ui512_qX2_ui_set', self, s_ui, PACKAGE='SoftPosit');

}

attr(`ui512_qX2_ui_set`, 'returnType') = 'void'
attr(`ui512_qX2_ui_set`, "inputTypes") = c('_p_ui512_qX2', 'integer')
class(`ui512_qX2_ui_set`) = c("SWIGFunction", class('ui512_qX2_ui_set'))

# Start of ui512_qX2_ui_get

`ui512_qX2_ui_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_ui512_qX2_ui_get', self, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_unsigned_long_long", ref=ans) ;

  ans

}

attr(`ui512_qX2_ui_get`, 'returnType') = 'integer'
attr(`ui512_qX2_ui_get`, "inputTypes") = c('_p_ui512_qX2')
class(`ui512_qX2_ui_get`) = c("SWIGFunction", class('ui512_qX2_ui_get'))

# Start of ui512_qX2_q_set

`ui512_qX2_q_set` = function(self, s_q)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  if (inherits(s_q, "ExternalReference")) s_q = slot(s_q,"ref")
  ;.Call('R_swig_ui512_qX2_q_set', self, s_q, PACKAGE='SoftPosit');

}

attr(`ui512_qX2_q_set`, 'returnType') = 'void'
attr(`ui512_qX2_q_set`, "inputTypes") = c('_p_ui512_qX2', '_p_quire_2_t')
class(`ui512_qX2_q_set`) = c("SWIGFunction", class('ui512_qX2_q_set'))

# Start of ui512_qX2_q_get

`ui512_qX2_q_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;ans = .Call('R_swig_ui512_qX2_q_get', self, PACKAGE='SoftPosit');
  ans <- new("_p_quire_2_t", ref=ans) ;

  ans

}

attr(`ui512_qX2_q_get`, 'returnType') = '_p_quire_2_t'
attr(`ui512_qX2_q_get`, "inputTypes") = c('_p_ui512_qX2')
class(`ui512_qX2_q_get`) = c("SWIGFunction", class('ui512_qX2_q_get'))

# Start of new_ui512_qX2

`ui512_qX2` = function()
{
  ;ans = .Call('R_swig_new_ui512_qX2', PACKAGE='SoftPosit');
  ans <- new("_p_ui512_qX2", ref=ans) ;

  reg.finalizer(ans@ref, delete_ui512_qX2)
  ans

}

attr(`ui512_qX2`, 'returnType') = '_p_ui512_qX2'
class(`ui512_qX2`) = c("SWIGFunction", class('ui512_qX2'))

# Start of delete_ui512_qX2

`delete_ui512_qX2` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref")
  ;.Call('R_swig_delete_ui512_qX2', self, PACKAGE='SoftPosit');

}

attr(`delete_ui512_qX2`, 'returnType') = 'void'
attr(`delete_ui512_qX2`, "inputTypes") = c('_p_ui512_qX2')
class(`delete_ui512_qX2`) = c("SWIGFunction", class('delete_ui512_qX2'))

# Start of accessor method for ui512_qX2
setMethod('$', '_p_ui512_qX2', function(x, name)

{
  accessorFuns = list('ui' = ui512_qX2_ui_get, 'q' = ui512_qX2_q_get);
  vaccessors = c('ui', 'q');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for ui512_qX2
# Start of accessor method for ui512_qX2
setMethod('$<-', '_p_ui512_qX2', function(x, name, value)

{
  accessorFuns = list('ui' = ui512_qX2_ui_set, 'q' = ui512_qX2_q_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_ui512_qX2', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('ui' = ui512_qX2_ui_set, 'q' = ui512_qX2_q_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx))
    return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for ui512_qX2
setMethod('delete', '_p_ui512_qX2', function(obj) {delete_ui512_qX2(obj)})
# Start of ui32_to_p8

`ui32_to_p8` = function(s_arg1, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);

  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };

  ;ans = .Call('R_swig_ui32_to_p8', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`ui32_to_p8`, 'returnType') = '_p_posit8_t'
attr(`ui32_to_p8`, "inputTypes") = c('integer')
class(`ui32_to_p8`) = c("SWIGFunction", class('ui32_to_p8'))

# Start of ui32_to_p16

`ui32_to_p16` = function(s_arg1, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);

  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };

  ;ans = .Call('R_swig_ui32_to_p16', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`ui32_to_p16`, 'returnType') = '_p_posit16_t'
attr(`ui32_to_p16`, "inputTypes") = c('integer')
class(`ui32_to_p16`) = c("SWIGFunction", class('ui32_to_p16'))

# Start of ui32_to_p32

`ui32_to_p32` = function(s_arg1, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);

  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };

  ;ans = .Call('R_swig_ui32_to_p32', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`ui32_to_p32`, 'returnType') = '_p_posit32_t'
attr(`ui32_to_p32`, "inputTypes") = c('integer')
class(`ui32_to_p32`) = c("SWIGFunction", class('ui32_to_p32'))

# Start of ui64_to_p8

`ui64_to_p8` = function(s_arg1, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);

  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };

  ;ans = .Call('R_swig_ui64_to_p8', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`ui64_to_p8`, 'returnType') = '_p_posit8_t'
attr(`ui64_to_p8`, "inputTypes") = c('integer')
class(`ui64_to_p8`) = c("SWIGFunction", class('ui64_to_p8'))

# Start of ui64_to_p16

`ui64_to_p16` = function(s_arg1, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);

  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };

  ;ans = .Call('R_swig_ui64_to_p16', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`ui64_to_p16`, 'returnType') = '_p_posit16_t'
attr(`ui64_to_p16`, "inputTypes") = c('integer')
class(`ui64_to_p16`) = c("SWIGFunction", class('ui64_to_p16'))

# Start of ui64_to_p32

`ui64_to_p32` = function(s_arg1, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);

  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };

  ;ans = .Call('R_swig_ui64_to_p32', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`ui64_to_p32`, 'returnType') = '_p_posit32_t'
attr(`ui64_to_p32`, "inputTypes") = c('integer')
class(`ui64_to_p32`) = c("SWIGFunction", class('ui64_to_p32'))

# Start of i32_to_p8

`i32_to_p8` = function(s_arg1, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);

  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };

  ;ans = .Call('R_swig_i32_to_p8', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`i32_to_p8`, 'returnType') = '_p_posit8_t'
attr(`i32_to_p8`, "inputTypes") = c('integer')
class(`i32_to_p8`) = c("SWIGFunction", class('i32_to_p8'))

# Start of i32_to_p16

`i32_to_p16` = function(s_arg1, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);

  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };

  ;ans = .Call('R_swig_i32_to_p16', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`i32_to_p16`, 'returnType') = '_p_posit16_t'
attr(`i32_to_p16`, "inputTypes") = c('integer')
class(`i32_to_p16`) = c("SWIGFunction", class('i32_to_p16'))

# Start of i32_to_p32

`i32_to_p32` = function(s_arg1, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);

  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };

  ;ans = .Call('R_swig_i32_to_p32', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`i32_to_p32`, 'returnType') = '_p_posit32_t'
attr(`i32_to_p32`, "inputTypes") = c('integer')
class(`i32_to_p32`) = c("SWIGFunction", class('i32_to_p32'))

# Start of i64_to_p8
#' @useDynLib SoftPosit R_swig_i64_to_p8
`i64_to_p8` = function(s_arg1, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);

  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };

  ;ans = .Call('R_swig_i64_to_p8', s_arg1, as.logical(.copy));
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`i64_to_p8`, 'returnType') = '_p_posit8_t'
attr(`i64_to_p8`, "inputTypes") = c('integer')
class(`i64_to_p8`) = c("SWIGFunction", class('i64_to_p8'))

# Start of i64_to_p16

`i64_to_p16` = function(s_arg1, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);

  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };

  ;ans = .Call('R_swig_i64_to_p16', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`i64_to_p16`, 'returnType') = '_p_posit16_t'
attr(`i64_to_p16`, "inputTypes") = c('integer')
class(`i64_to_p16`) = c("SWIGFunction", class('i64_to_p16'))

# Start of i64_to_p32

`i64_to_p32` = function(s_arg1, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);

  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };

  ;ans = .Call('R_swig_i64_to_p32', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`i64_to_p32`, 'returnType') = '_p_posit32_t'
attr(`i64_to_p32`, "inputTypes") = c('integer')
class(`i64_to_p32`) = c("SWIGFunction", class('i64_to_p32'))

# Start of p8_to_ui32

`p8_to_ui32` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_p8_to_ui32', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p8_to_ui32`, 'returnType') = 'integer'
attr(`p8_to_ui32`, "inputTypes") = c('_p_posit8_t')
class(`p8_to_ui32`) = c("SWIGFunction", class('p8_to_ui32'))

# Start of p8_to_ui64

`p8_to_ui64` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_p8_to_ui64', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p8_to_ui64`, 'returnType') = 'integer'
attr(`p8_to_ui64`, "inputTypes") = c('_p_posit8_t')
class(`p8_to_ui64`) = c("SWIGFunction", class('p8_to_ui64'))

# Start of p8_to_i32

`p8_to_i32` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_p8_to_i32', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p8_to_i32`, 'returnType') = 'integer'
attr(`p8_to_i32`, "inputTypes") = c('_p_posit8_t')
class(`p8_to_i32`) = c("SWIGFunction", class('p8_to_i32'))

# Start of p8_to_i64

`p8_to_i64` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_p8_to_i64', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p8_to_i64`, 'returnType') = 'integer'
attr(`p8_to_i64`, "inputTypes") = c('_p_posit8_t')
class(`p8_to_i64`) = c("SWIGFunction", class('p8_to_i64'))

# Start of p8_to_p16

`p8_to_p16` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;ans = .Call('R_swig_p8_to_p16', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`p8_to_p16`, 'returnType') = '_p_posit16_t'
attr(`p8_to_p16`, "inputTypes") = c('_p_posit8_t')
class(`p8_to_p16`) = c("SWIGFunction", class('p8_to_p16'))

# Start of p8_to_p32

`p8_to_p32` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;ans = .Call('R_swig_p8_to_p32', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`p8_to_p32`, 'returnType') = '_p_posit32_t'
attr(`p8_to_p32`, "inputTypes") = c('_p_posit8_t')
class(`p8_to_p32`) = c("SWIGFunction", class('p8_to_p32'))

# Start of p8_to_pX2

`p8_to_pX2` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  s_arg2 = as.integer(s_arg2);

  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };

  ;ans = .Call('R_swig_p8_to_pX2', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`p8_to_pX2`, 'returnType') = '_p_posit_2_t'
attr(`p8_to_pX2`, "inputTypes") = c('_p_posit8_t', 'integer')
class(`p8_to_pX2`) = c("SWIGFunction", class('p8_to_pX2'))

# Start of p8_roundToInt

`p8_roundToInt` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;ans = .Call('R_swig_p8_roundToInt', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`p8_roundToInt`, 'returnType') = '_p_posit8_t'
attr(`p8_roundToInt`, "inputTypes") = c('_p_posit8_t')
class(`p8_roundToInt`) = c("SWIGFunction", class('p8_roundToInt'))

# Start of p8_add

`p8_add` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;ans = .Call('R_swig_p8_add', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`p8_add`, 'returnType') = '_p_posit8_t'
attr(`p8_add`, "inputTypes") = c('_p_posit8_t', '_p_posit8_t')
class(`p8_add`) = c("SWIGFunction", class('p8_add'))

# Start of p8_sub

`p8_sub` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;ans = .Call('R_swig_p8_sub', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`p8_sub`, 'returnType') = '_p_posit8_t'
attr(`p8_sub`, "inputTypes") = c('_p_posit8_t', '_p_posit8_t')
class(`p8_sub`) = c("SWIGFunction", class('p8_sub'))

# Start of p8_mul

`p8_mul` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;ans = .Call('R_swig_p8_mul', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`p8_mul`, 'returnType') = '_p_posit8_t'
attr(`p8_mul`, "inputTypes") = c('_p_posit8_t', '_p_posit8_t')
class(`p8_mul`) = c("SWIGFunction", class('p8_mul'))

# Start of p8_mulAdd

`p8_mulAdd` = function(s_arg1, s_arg2, s_arg3, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  if (inherits(s_arg3, "ExternalReference")) s_arg3 = slot(s_arg3,"ref")
  ;ans = .Call('R_swig_p8_mulAdd', s_arg1, s_arg2, s_arg3, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`p8_mulAdd`, 'returnType') = '_p_posit8_t'
attr(`p8_mulAdd`, "inputTypes") = c('_p_posit8_t', '_p_posit8_t', '_p_posit8_t')
class(`p8_mulAdd`) = c("SWIGFunction", class('p8_mulAdd'))

# Start of p8_div

`p8_div` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;ans = .Call('R_swig_p8_div', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`p8_div`, 'returnType') = '_p_posit8_t'
attr(`p8_div`, "inputTypes") = c('_p_posit8_t', '_p_posit8_t')
class(`p8_div`) = c("SWIGFunction", class('p8_div'))

# Start of p8_sqrt

`p8_sqrt` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;ans = .Call('R_swig_p8_sqrt', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`p8_sqrt`, 'returnType') = '_p_posit8_t'
attr(`p8_sqrt`, "inputTypes") = c('_p_posit8_t')
class(`p8_sqrt`) = c("SWIGFunction", class('p8_sqrt'))

# Start of p8_eq

`p8_eq` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;.Call('R_swig_p8_eq', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p8_eq`, 'returnType') = 'logical'
attr(`p8_eq`, "inputTypes") = c('_p_posit8_t', '_p_posit8_t')
class(`p8_eq`) = c("SWIGFunction", class('p8_eq'))

# Start of p8_le

`p8_le` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;.Call('R_swig_p8_le', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p8_le`, 'returnType') = 'logical'
attr(`p8_le`, "inputTypes") = c('_p_posit8_t', '_p_posit8_t')
class(`p8_le`) = c("SWIGFunction", class('p8_le'))

# Start of p8_lt

`p8_lt` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;.Call('R_swig_p8_lt', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p8_lt`, 'returnType') = 'logical'
attr(`p8_lt`, "inputTypes") = c('_p_posit8_t', '_p_posit8_t')
class(`p8_lt`) = c("SWIGFunction", class('p8_lt'))

# Start of q8_fdp_add

`q8_fdp_add` = function(s_arg1, s_arg2, s_arg3, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  if (inherits(s_arg3, "ExternalReference")) s_arg3 = slot(s_arg3,"ref")
  ;ans = .Call('R_swig_q8_fdp_add', s_arg1, s_arg2, s_arg3, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_quire8_t", ref=ans);

  ans

}

attr(`q8_fdp_add`, 'returnType') = '_p_quire8_t'
attr(`q8_fdp_add`, "inputTypes") = c('_p_quire8_t', '_p_posit8_t', '_p_posit8_t')
class(`q8_fdp_add`) = c("SWIGFunction", class('q8_fdp_add'))

# Start of q8_fdp_sub

`q8_fdp_sub` = function(s_arg1, s_arg2, s_arg3, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  if (inherits(s_arg3, "ExternalReference")) s_arg3 = slot(s_arg3,"ref")
  ;ans = .Call('R_swig_q8_fdp_sub', s_arg1, s_arg2, s_arg3, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_quire8_t", ref=ans);

  ans

}

attr(`q8_fdp_sub`, 'returnType') = '_p_quire8_t'
attr(`q8_fdp_sub`, "inputTypes") = c('_p_quire8_t', '_p_posit8_t', '_p_posit8_t')
class(`q8_fdp_sub`) = c("SWIGFunction", class('q8_fdp_sub'))

# Start of q8_to_p8

`q8_to_p8` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;ans = .Call('R_swig_q8_to_p8', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`q8_to_p8`, 'returnType') = '_p_posit8_t'
attr(`q8_to_p8`, "inputTypes") = c('_p_quire8_t')
class(`q8_to_p8`) = c("SWIGFunction", class('q8_to_p8'))

# Start of p8_int

`p8_int` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_p8_int', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p8_int`, 'returnType') = 'integer'
attr(`p8_int`, "inputTypes") = c('_p_posit8_t')
class(`p8_int`) = c("SWIGFunction", class('p8_int'))

# Start of q8Clr

`q8Clr` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_q8Clr', as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_quire8_t", ref=ans);

  ans

}

attr(`q8Clr`, 'returnType') = '_p_quire8_t'
class(`q8Clr`) = c("SWIGFunction", class('q8Clr'))

# Start of convertP8ToDouble

`convertP8ToDouble` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_convertP8ToDouble', s_arg1, as.logical(.copy));

}

attr(`convertP8ToDouble`, 'returnType') = 'numeric'
attr(`convertP8ToDouble`, "inputTypes") = c('_p_posit8_t')
class(`convertP8ToDouble`) = c("SWIGFunction", class('convertP8ToDouble'))

# Start of convertDoubleToP8

`convertDoubleToP8` = function(s_arg1, .copy = FALSE)
{
  ;ans = .Call('R_swig_convertDoubleToP8', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`convertDoubleToP8`, 'returnType') = '_p_posit8_t'
attr(`convertDoubleToP8`, "inputTypes") = c('numeric')
class(`convertDoubleToP8`) = c("SWIGFunction", class('convertDoubleToP8'))

# Start of p16_to_ui32

`p16_to_ui32` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_p16_to_ui32', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p16_to_ui32`, 'returnType') = 'integer'
attr(`p16_to_ui32`, "inputTypes") = c('_p_posit16_t')
class(`p16_to_ui32`) = c("SWIGFunction", class('p16_to_ui32'))

# Start of p16_to_ui64

`p16_to_ui64` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_p16_to_ui64', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p16_to_ui64`, 'returnType') = 'integer'
attr(`p16_to_ui64`, "inputTypes") = c('_p_posit16_t')
class(`p16_to_ui64`) = c("SWIGFunction", class('p16_to_ui64'))

# Start of p16_to_i32

`p16_to_i32` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_p16_to_i32', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p16_to_i32`, 'returnType') = 'integer'
attr(`p16_to_i32`, "inputTypes") = c('_p_posit16_t')
class(`p16_to_i32`) = c("SWIGFunction", class('p16_to_i32'))

# Start of p16_to_i64

`p16_to_i64` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_p16_to_i64', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p16_to_i64`, 'returnType') = 'integer'
attr(`p16_to_i64`, "inputTypes") = c('_p_posit16_t')
class(`p16_to_i64`) = c("SWIGFunction", class('p16_to_i64'))

# Start of p16_to_p8

`p16_to_p8` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;ans = .Call('R_swig_p16_to_p8', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`p16_to_p8`, 'returnType') = '_p_posit8_t'
attr(`p16_to_p8`, "inputTypes") = c('_p_posit16_t')
class(`p16_to_p8`) = c("SWIGFunction", class('p16_to_p8'))

# Start of p16_to_p32

`p16_to_p32` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;ans = .Call('R_swig_p16_to_p32', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`p16_to_p32`, 'returnType') = '_p_posit32_t'
attr(`p16_to_p32`, "inputTypes") = c('_p_posit16_t')
class(`p16_to_p32`) = c("SWIGFunction", class('p16_to_p32'))

# Start of p16_to_pX2

`p16_to_pX2` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  s_arg2 = as.integer(s_arg2);

  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };

  ;ans = .Call('R_swig_p16_to_pX2', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`p16_to_pX2`, 'returnType') = '_p_posit_2_t'
attr(`p16_to_pX2`, "inputTypes") = c('_p_posit16_t', 'integer')
class(`p16_to_pX2`) = c("SWIGFunction", class('p16_to_pX2'))

# Start of p16_roundToInt

`p16_roundToInt` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;ans = .Call('R_swig_p16_roundToInt', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`p16_roundToInt`, 'returnType') = '_p_posit16_t'
attr(`p16_roundToInt`, "inputTypes") = c('_p_posit16_t')
class(`p16_roundToInt`) = c("SWIGFunction", class('p16_roundToInt'))

# Start of p16_add

`p16_add` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;ans = .Call('R_swig_p16_add', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`p16_add`, 'returnType') = '_p_posit16_t'
attr(`p16_add`, "inputTypes") = c('_p_posit16_t', '_p_posit16_t')
class(`p16_add`) = c("SWIGFunction", class('p16_add'))

# Start of p16_sub

`p16_sub` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;ans = .Call('R_swig_p16_sub', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`p16_sub`, 'returnType') = '_p_posit16_t'
attr(`p16_sub`, "inputTypes") = c('_p_posit16_t', '_p_posit16_t')
class(`p16_sub`) = c("SWIGFunction", class('p16_sub'))

# Start of p16_mul

`p16_mul` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;ans = .Call('R_swig_p16_mul', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`p16_mul`, 'returnType') = '_p_posit16_t'
attr(`p16_mul`, "inputTypes") = c('_p_posit16_t', '_p_posit16_t')
class(`p16_mul`) = c("SWIGFunction", class('p16_mul'))

# Start of p16_mulAdd

`p16_mulAdd` = function(s_arg1, s_arg2, s_arg3, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  if (inherits(s_arg3, "ExternalReference")) s_arg3 = slot(s_arg3,"ref")
  ;ans = .Call('R_swig_p16_mulAdd', s_arg1, s_arg2, s_arg3, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`p16_mulAdd`, 'returnType') = '_p_posit16_t'
attr(`p16_mulAdd`, "inputTypes") = c('_p_posit16_t', '_p_posit16_t', '_p_posit16_t')
class(`p16_mulAdd`) = c("SWIGFunction", class('p16_mulAdd'))

# Start of p16_div

`p16_div` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;ans = .Call('R_swig_p16_div', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`p16_div`, 'returnType') = '_p_posit16_t'
attr(`p16_div`, "inputTypes") = c('_p_posit16_t', '_p_posit16_t')
class(`p16_div`) = c("SWIGFunction", class('p16_div'))

# Start of p16_sqrt

`p16_sqrt` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;ans = .Call('R_swig_p16_sqrt', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`p16_sqrt`, 'returnType') = '_p_posit16_t'
attr(`p16_sqrt`, "inputTypes") = c('_p_posit16_t')
class(`p16_sqrt`) = c("SWIGFunction", class('p16_sqrt'))

# Start of p16_eq

`p16_eq` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;.Call('R_swig_p16_eq', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p16_eq`, 'returnType') = 'logical'
attr(`p16_eq`, "inputTypes") = c('_p_posit16_t', '_p_posit16_t')
class(`p16_eq`) = c("SWIGFunction", class('p16_eq'))

# Start of p16_le

`p16_le` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;.Call('R_swig_p16_le', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p16_le`, 'returnType') = 'logical'
attr(`p16_le`, "inputTypes") = c('_p_posit16_t', '_p_posit16_t')
class(`p16_le`) = c("SWIGFunction", class('p16_le'))

# Start of p16_lt

`p16_lt` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;.Call('R_swig_p16_lt', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p16_lt`, 'returnType') = 'logical'
attr(`p16_lt`, "inputTypes") = c('_p_posit16_t', '_p_posit16_t')
class(`p16_lt`) = c("SWIGFunction", class('p16_lt'))

# Start of q16_fdp_add

`q16_fdp_add` = function(s_arg1, s_arg2, s_arg3, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  if (inherits(s_arg3, "ExternalReference")) s_arg3 = slot(s_arg3,"ref")
  ;ans = .Call('R_swig_q16_fdp_add', s_arg1, s_arg2, s_arg3, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_quire16_t", ref=ans);

  ans

}

attr(`q16_fdp_add`, 'returnType') = '_p_quire16_t'
attr(`q16_fdp_add`, "inputTypes") = c('_p_quire16_t', '_p_posit16_t', '_p_posit16_t')
class(`q16_fdp_add`) = c("SWIGFunction", class('q16_fdp_add'))

# Start of q16_fdp_sub

`q16_fdp_sub` = function(s_arg1, s_arg2, s_arg3, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  if (inherits(s_arg3, "ExternalReference")) s_arg3 = slot(s_arg3,"ref")
  ;ans = .Call('R_swig_q16_fdp_sub', s_arg1, s_arg2, s_arg3, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_quire16_t", ref=ans);

  ans

}

attr(`q16_fdp_sub`, 'returnType') = '_p_quire16_t'
attr(`q16_fdp_sub`, "inputTypes") = c('_p_quire16_t', '_p_posit16_t', '_p_posit16_t')
class(`q16_fdp_sub`) = c("SWIGFunction", class('q16_fdp_sub'))

# Start of convertQ16ToP16

`convertQ16ToP16` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;ans = .Call('R_swig_convertQ16ToP16', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`convertQ16ToP16`, 'returnType') = '_p_posit16_t'
attr(`convertQ16ToP16`, "inputTypes") = c('_p_quire16_t')
class(`convertQ16ToP16`) = c("SWIGFunction", class('convertQ16ToP16'))

# Start of q16_to_p16

`q16_to_p16` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;ans = .Call('R_swig_q16_to_p16', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`q16_to_p16`, 'returnType') = '_p_posit16_t'
attr(`q16_to_p16`, "inputTypes") = c('_p_quire16_t')
class(`q16_to_p16`) = c("SWIGFunction", class('q16_to_p16'))

# Start of q16_TwosComplement

`q16_TwosComplement` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;ans = .Call('R_swig_q16_TwosComplement', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_quire16_t", ref=ans);

  ans

}

attr(`q16_TwosComplement`, 'returnType') = '_p_quire16_t'
attr(`q16_TwosComplement`, "inputTypes") = c('_p_quire16_t')
class(`q16_TwosComplement`) = c("SWIGFunction", class('q16_TwosComplement'))

# Start of p16_int

`p16_int` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_p16_int', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p16_int`, 'returnType') = 'integer'
attr(`p16_int`, "inputTypes") = c('_p_posit16_t')
class(`p16_int`) = c("SWIGFunction", class('p16_int'))

# Start of printBinary

`printBinary` = function(s_arg1, s_arg2)
{
  s_arg1 = as.integer(s_arg1);
  s_arg2 = as.integer(s_arg2);

  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };

  ;.Call('R_swig_printBinary', s_arg1, s_arg2, PACKAGE='SoftPosit');

}

attr(`printBinary`, 'returnType') = 'void'
attr(`printBinary`, "inputTypes") = c('integer', 'integer')
class(`printBinary`) = c("SWIGFunction", class('printBinary'))

# Start of printBinaryPX

`printBinaryPX` = function(s_arg1, s_arg2)
{
  s_arg1 = as.integer(s_arg1);
  s_arg2 = as.integer(s_arg2);

  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };

  ;.Call('R_swig_printBinaryPX', s_arg1, s_arg2, PACKAGE='SoftPosit');

}

attr(`printBinaryPX`, 'returnType') = 'void'
attr(`printBinaryPX`, "inputTypes") = c('integer', 'integer')
class(`printBinaryPX`) = c("SWIGFunction", class('printBinaryPX'))

# Start of printHex

`printHex` = function(s_arg1)
{
  s_arg1 = as.integer(s_arg1);

  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };

  ;.Call('R_swig_printHex', s_arg1, PACKAGE='SoftPosit');

}

attr(`printHex`, 'returnType') = 'void'
attr(`printHex`, "inputTypes") = c('integer')
class(`printHex`) = c("SWIGFunction", class('printHex'))

# Start of printHex64

`printHex64` = function(s_arg1)
{
  s_arg1 = as.integer(s_arg1);

  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };

  ;.Call('R_swig_printHex64', s_arg1, PACKAGE='SoftPosit');

}

attr(`printHex64`, 'returnType') = 'void'
attr(`printHex64`, "inputTypes") = c('integer')
class(`printHex64`) = c("SWIGFunction", class('printHex64'))

# Start of printHexPX

`printHexPX` = function(s_arg1, s_arg2)
{
  s_arg1 = as.integer(s_arg1);

  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };

  s_arg2 = as.integer(s_arg2);

  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };

  ;.Call('R_swig_printHexPX', s_arg1, s_arg2, PACKAGE='SoftPosit');

}

attr(`printHexPX`, 'returnType') = 'void'
attr(`printHexPX`, "inputTypes") = c('integer', 'integer')
class(`printHexPX`) = c("SWIGFunction", class('printHexPX'))

# Start of q16Clr

`q16Clr` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_q16Clr', as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_quire16_t", ref=ans);

  ans

}

attr(`q16Clr`, 'returnType') = '_p_quire16_t'
class(`q16Clr`) = c("SWIGFunction", class('q16Clr'))

# Start of convertP16ToDouble

`convertP16ToDouble` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_convertP16ToDouble', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`convertP16ToDouble`, 'returnType') = 'numeric'
attr(`convertP16ToDouble`, "inputTypes") = c('_p_posit16_t')
class(`convertP16ToDouble`) = c("SWIGFunction", class('convertP16ToDouble'))

# Start of convertFloatToP16

`convertFloatToP16` = function(s_arg1, .copy = FALSE)
{
  ;ans = .Call('R_swig_convertFloatToP16', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`convertFloatToP16`, 'returnType') = '_p_posit16_t'
attr(`convertFloatToP16`, "inputTypes") = c('numeric')
class(`convertFloatToP16`) = c("SWIGFunction", class('convertFloatToP16'))

# Start of convertDoubleToP16

`convertDoubleToP16` = function(s_arg1, .copy = FALSE)
{
  ;ans = .Call('R_swig_convertDoubleToP16', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`convertDoubleToP16`, 'returnType') = '_p_posit16_t'
attr(`convertDoubleToP16`, "inputTypes") = c('numeric')
class(`convertDoubleToP16`) = c("SWIGFunction", class('convertDoubleToP16'))

# Start of p32_to_ui32

`p32_to_ui32` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_p32_to_ui32', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p32_to_ui32`, 'returnType') = 'integer'
attr(`p32_to_ui32`, "inputTypes") = c('_p_posit32_t')
class(`p32_to_ui32`) = c("SWIGFunction", class('p32_to_ui32'))

# Start of p32_to_ui64

`p32_to_ui64` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_p32_to_ui64', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p32_to_ui64`, 'returnType') = 'integer'
attr(`p32_to_ui64`, "inputTypes") = c('_p_posit32_t')
class(`p32_to_ui64`) = c("SWIGFunction", class('p32_to_ui64'))

# Start of p32_to_i32

`p32_to_i32` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_p32_to_i32', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p32_to_i32`, 'returnType') = 'integer'
attr(`p32_to_i32`, "inputTypes") = c('_p_posit32_t')
class(`p32_to_i32`) = c("SWIGFunction", class('p32_to_i32'))

# Start of p32_to_i64

`p32_to_i64` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_p32_to_i64', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p32_to_i64`, 'returnType') = 'integer'
attr(`p32_to_i64`, "inputTypes") = c('_p_posit32_t')
class(`p32_to_i64`) = c("SWIGFunction", class('p32_to_i64'))

# Start of p32_to_p8

`p32_to_p8` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;ans = .Call('R_swig_p32_to_p8', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`p32_to_p8`, 'returnType') = '_p_posit8_t'
attr(`p32_to_p8`, "inputTypes") = c('_p_posit32_t')
class(`p32_to_p8`) = c("SWIGFunction", class('p32_to_p8'))

# Start of p32_to_p16

`p32_to_p16` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;ans = .Call('R_swig_p32_to_p16', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`p32_to_p16`, 'returnType') = '_p_posit16_t'
attr(`p32_to_p16`, "inputTypes") = c('_p_posit32_t')
class(`p32_to_p16`) = c("SWIGFunction", class('p32_to_p16'))

# Start of p32_roundToInt

`p32_roundToInt` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;ans = .Call('R_swig_p32_roundToInt', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`p32_roundToInt`, 'returnType') = '_p_posit32_t'
attr(`p32_roundToInt`, "inputTypes") = c('_p_posit32_t')
class(`p32_roundToInt`) = c("SWIGFunction", class('p32_roundToInt'))

# Start of p32_add

`p32_add` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;ans = .Call('R_swig_p32_add', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`p32_add`, 'returnType') = '_p_posit32_t'
attr(`p32_add`, "inputTypes") = c('_p_posit32_t', '_p_posit32_t')
class(`p32_add`) = c("SWIGFunction", class('p32_add'))

# Start of p32_sub

`p32_sub` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;ans = .Call('R_swig_p32_sub', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`p32_sub`, 'returnType') = '_p_posit32_t'
attr(`p32_sub`, "inputTypes") = c('_p_posit32_t', '_p_posit32_t')
class(`p32_sub`) = c("SWIGFunction", class('p32_sub'))

# Start of p32_mul

`p32_mul` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;ans = .Call('R_swig_p32_mul', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`p32_mul`, 'returnType') = '_p_posit32_t'
attr(`p32_mul`, "inputTypes") = c('_p_posit32_t', '_p_posit32_t')
class(`p32_mul`) = c("SWIGFunction", class('p32_mul'))

# Start of p32_mulAdd

`p32_mulAdd` = function(s_arg1, s_arg2, s_arg3, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  if (inherits(s_arg3, "ExternalReference")) s_arg3 = slot(s_arg3,"ref")
  ;ans = .Call('R_swig_p32_mulAdd', s_arg1, s_arg2, s_arg3, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`p32_mulAdd`, 'returnType') = '_p_posit32_t'
attr(`p32_mulAdd`, "inputTypes") = c('_p_posit32_t', '_p_posit32_t', '_p_posit32_t')
class(`p32_mulAdd`) = c("SWIGFunction", class('p32_mulAdd'))

# Start of p32_div

`p32_div` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;ans = .Call('R_swig_p32_div', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`p32_div`, 'returnType') = '_p_posit32_t'
attr(`p32_div`, "inputTypes") = c('_p_posit32_t', '_p_posit32_t')
class(`p32_div`) = c("SWIGFunction", class('p32_div'))

# Start of p32_sqrt

`p32_sqrt` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;ans = .Call('R_swig_p32_sqrt', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`p32_sqrt`, 'returnType') = '_p_posit32_t'
attr(`p32_sqrt`, "inputTypes") = c('_p_posit32_t')
class(`p32_sqrt`) = c("SWIGFunction", class('p32_sqrt'))

# Start of p32_eq

`p32_eq` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;.Call('R_swig_p32_eq', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p32_eq`, 'returnType') = 'logical'
attr(`p32_eq`, "inputTypes") = c('_p_posit32_t', '_p_posit32_t')
class(`p32_eq`) = c("SWIGFunction", class('p32_eq'))

# Start of p32_le

`p32_le` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;.Call('R_swig_p32_le', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p32_le`, 'returnType') = 'logical'
attr(`p32_le`, "inputTypes") = c('_p_posit32_t', '_p_posit32_t')
class(`p32_le`) = c("SWIGFunction", class('p32_le'))

# Start of p32_lt

`p32_lt` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;.Call('R_swig_p32_lt', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p32_lt`, 'returnType') = 'logical'
attr(`p32_lt`, "inputTypes") = c('_p_posit32_t', '_p_posit32_t')
class(`p32_lt`) = c("SWIGFunction", class('p32_lt'))

# Start of p32_to_pX2

`p32_to_pX2` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  s_arg2 = as.integer(s_arg2);

  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };

  ;ans = .Call('R_swig_p32_to_pX2', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`p32_to_pX2`, 'returnType') = '_p_posit_2_t'
attr(`p32_to_pX2`, "inputTypes") = c('_p_posit32_t', 'integer')
class(`p32_to_pX2`) = c("SWIGFunction", class('p32_to_pX2'))

# Start of p32_int

`p32_int` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_p32_int', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`p32_int`, 'returnType') = 'integer'
attr(`p32_int`, "inputTypes") = c('_p_posit32_t')
class(`p32_int`) = c("SWIGFunction", class('p32_int'))

# Start of q32_fdp_add

`q32_fdp_add` = function(s_arg1, s_arg2, s_arg3, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  if (inherits(s_arg3, "ExternalReference")) s_arg3 = slot(s_arg3,"ref")
  ;ans = .Call('R_swig_q32_fdp_add', s_arg1, s_arg2, s_arg3, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_quire32_t", ref=ans);

  ans

}

attr(`q32_fdp_add`, 'returnType') = '_p_quire32_t'
attr(`q32_fdp_add`, "inputTypes") = c('_p_quire32_t', '_p_posit32_t', '_p_posit32_t')
class(`q32_fdp_add`) = c("SWIGFunction", class('q32_fdp_add'))

# Start of q32_fdp_sub

`q32_fdp_sub` = function(s_arg1, s_arg2, s_arg3, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  if (inherits(s_arg3, "ExternalReference")) s_arg3 = slot(s_arg3,"ref")
  ;ans = .Call('R_swig_q32_fdp_sub', s_arg1, s_arg2, s_arg3, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_quire32_t", ref=ans);

  ans

}

attr(`q32_fdp_sub`, 'returnType') = '_p_quire32_t'
attr(`q32_fdp_sub`, "inputTypes") = c('_p_quire32_t', '_p_posit32_t', '_p_posit32_t')
class(`q32_fdp_sub`) = c("SWIGFunction", class('q32_fdp_sub'))

# Start of q32_to_p32

`q32_to_p32` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;ans = .Call('R_swig_q32_to_p32', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`q32_to_p32`, 'returnType') = '_p_posit32_t'
attr(`q32_to_p32`, "inputTypes") = c('_p_quire32_t')
class(`q32_to_p32`) = c("SWIGFunction", class('q32_to_p32'))

# Start of q32_TwosComplement

`q32_TwosComplement` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;ans = .Call('R_swig_q32_TwosComplement', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_quire32_t", ref=ans);

  ans

}

attr(`q32_TwosComplement`, 'returnType') = '_p_quire32_t'
attr(`q32_TwosComplement`, "inputTypes") = c('_p_quire32_t')
class(`q32_TwosComplement`) = c("SWIGFunction", class('q32_TwosComplement'))

# Start of q32Clr

`q32Clr` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_q32Clr', as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_quire32_t", ref=ans);

  ans

}

attr(`q32Clr`, 'returnType') = '_p_quire32_t'
class(`q32Clr`) = c("SWIGFunction", class('q32Clr'))

# Start of convertP32ToDouble

`convertP32ToDouble` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_convertP32ToDouble', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`convertP32ToDouble`, 'returnType') = 'numeric'
attr(`convertP32ToDouble`, "inputTypes") = c('_p_posit32_t')
class(`convertP32ToDouble`) = c("SWIGFunction", class('convertP32ToDouble'))

# Start of convertFloatToP32

`convertFloatToP32` = function(s_arg1, .copy = FALSE)
{
  ;ans = .Call('R_swig_convertFloatToP32', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`convertFloatToP32`, 'returnType') = '_p_posit32_t'
attr(`convertFloatToP32`, "inputTypes") = c('numeric')
class(`convertFloatToP32`) = c("SWIGFunction", class('convertFloatToP32'))

# Start of convertDoubleToP32

`convertDoubleToP32` = function(s_arg1, .copy = FALSE)
{
  ;ans = .Call('R_swig_convertDoubleToP32', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`convertDoubleToP32`, 'returnType') = '_p_posit32_t'
attr(`convertDoubleToP32`, "inputTypes") = c('numeric')
class(`convertDoubleToP32`) = c("SWIGFunction", class('convertDoubleToP32'))

# Start of pX2_add

`pX2_add` = function(s_arg1, s_arg2, s_arg3, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  s_arg3 = as.integer(s_arg3);

  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };

  ;ans = .Call('R_swig_pX2_add', s_arg1, s_arg2, s_arg3, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`pX2_add`, 'returnType') = '_p_posit_2_t'
attr(`pX2_add`, "inputTypes") = c('_p_posit_2_t', '_p_posit_2_t', 'integer')
class(`pX2_add`) = c("SWIGFunction", class('pX2_add'))

# Start of pX2_sub

`pX2_sub` = function(s_arg1, s_arg2, s_arg3, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  s_arg3 = as.integer(s_arg3);

  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };

  ;ans = .Call('R_swig_pX2_sub', s_arg1, s_arg2, s_arg3, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`pX2_sub`, 'returnType') = '_p_posit_2_t'
attr(`pX2_sub`, "inputTypes") = c('_p_posit_2_t', '_p_posit_2_t', 'integer')
class(`pX2_sub`) = c("SWIGFunction", class('pX2_sub'))

# Start of pX2_mul

`pX2_mul` = function(s_arg1, s_arg2, s_arg3, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  s_arg3 = as.integer(s_arg3);

  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };

  ;ans = .Call('R_swig_pX2_mul', s_arg1, s_arg2, s_arg3, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`pX2_mul`, 'returnType') = '_p_posit_2_t'
attr(`pX2_mul`, "inputTypes") = c('_p_posit_2_t', '_p_posit_2_t', 'integer')
class(`pX2_mul`) = c("SWIGFunction", class('pX2_mul'))

# Start of pX2_div

`pX2_div` = function(s_arg1, s_arg2, s_arg3, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  s_arg3 = as.integer(s_arg3);

  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };

  ;ans = .Call('R_swig_pX2_div', s_arg1, s_arg2, s_arg3, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`pX2_div`, 'returnType') = '_p_posit_2_t'
attr(`pX2_div`, "inputTypes") = c('_p_posit_2_t', '_p_posit_2_t', 'integer')
class(`pX2_div`) = c("SWIGFunction", class('pX2_div'))

# Start of pX2_mulAdd

`pX2_mulAdd` = function(s_arg1, s_arg2, s_arg3, s_arg4, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  if (inherits(s_arg3, "ExternalReference")) s_arg3 = slot(s_arg3,"ref")
  s_arg4 = as.integer(s_arg4);

  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };

  ;ans = .Call('R_swig_pX2_mulAdd', s_arg1, s_arg2, s_arg3, s_arg4, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`pX2_mulAdd`, 'returnType') = '_p_posit_2_t'
attr(`pX2_mulAdd`, "inputTypes") = c('_p_posit_2_t', '_p_posit_2_t', '_p_posit_2_t', 'integer')
class(`pX2_mulAdd`) = c("SWIGFunction", class('pX2_mulAdd'))

# Start of pX2_roundToInt

`pX2_roundToInt` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  s_arg2 = as.integer(s_arg2);

  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };

  ;ans = .Call('R_swig_pX2_roundToInt', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`pX2_roundToInt`, 'returnType') = '_p_posit_2_t'
attr(`pX2_roundToInt`, "inputTypes") = c('_p_posit_2_t', 'integer')
class(`pX2_roundToInt`) = c("SWIGFunction", class('pX2_roundToInt'))

# Start of ui32_to_pX2

`ui32_to_pX2` = function(s_arg1, s_arg2, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);

  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };

  s_arg2 = as.integer(s_arg2);

  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };

  ;ans = .Call('R_swig_ui32_to_pX2', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`ui32_to_pX2`, 'returnType') = '_p_posit_2_t'
attr(`ui32_to_pX2`, "inputTypes") = c('integer', 'integer')
class(`ui32_to_pX2`) = c("SWIGFunction", class('ui32_to_pX2'))

# Start of ui64_to_pX2

`ui64_to_pX2` = function(s_arg1, s_arg2, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);

  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };

  s_arg2 = as.integer(s_arg2);

  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };

  ;ans = .Call('R_swig_ui64_to_pX2', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`ui64_to_pX2`, 'returnType') = '_p_posit_2_t'
attr(`ui64_to_pX2`, "inputTypes") = c('integer', 'integer')
class(`ui64_to_pX2`) = c("SWIGFunction", class('ui64_to_pX2'))

# Start of i32_to_pX2

`i32_to_pX2` = function(s_arg1, s_arg2, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);

  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };

  s_arg2 = as.integer(s_arg2);

  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };

  ;ans = .Call('R_swig_i32_to_pX2', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`i32_to_pX2`, 'returnType') = '_p_posit_2_t'
attr(`i32_to_pX2`, "inputTypes") = c('integer', 'integer')
class(`i32_to_pX2`) = c("SWIGFunction", class('i32_to_pX2'))

# Start of i64_to_pX2

`i64_to_pX2` = function(s_arg1, s_arg2, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);

  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };

  s_arg2 = as.integer(s_arg2);

  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };

  ;ans = .Call('R_swig_i64_to_pX2', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`i64_to_pX2`, 'returnType') = '_p_posit_2_t'
attr(`i64_to_pX2`, "inputTypes") = c('integer', 'integer')
class(`i64_to_pX2`) = c("SWIGFunction", class('i64_to_pX2'))

# Start of pX2_sqrt

`pX2_sqrt` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  s_arg2 = as.integer(s_arg2);

  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };

  ;ans = .Call('R_swig_pX2_sqrt', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`pX2_sqrt`, 'returnType') = '_p_posit_2_t'
attr(`pX2_sqrt`, "inputTypes") = c('_p_posit_2_t', 'integer')
class(`pX2_sqrt`) = c("SWIGFunction", class('pX2_sqrt'))

# Start of pX2_to_ui32

`pX2_to_ui32` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_pX2_to_ui32', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`pX2_to_ui32`, 'returnType') = 'integer'
attr(`pX2_to_ui32`, "inputTypes") = c('_p_posit_2_t')
class(`pX2_to_ui32`) = c("SWIGFunction", class('pX2_to_ui32'))

# Start of pX2_to_ui64

`pX2_to_ui64` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_pX2_to_ui64', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`pX2_to_ui64`, 'returnType') = 'integer'
attr(`pX2_to_ui64`, "inputTypes") = c('_p_posit_2_t')
class(`pX2_to_ui64`) = c("SWIGFunction", class('pX2_to_ui64'))

# Start of pX2_to_i32

`pX2_to_i32` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_pX2_to_i32', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`pX2_to_i32`, 'returnType') = 'integer'
attr(`pX2_to_i32`, "inputTypes") = c('_p_posit_2_t')
class(`pX2_to_i32`) = c("SWIGFunction", class('pX2_to_i32'))

# Start of pX2_to_i64

`pX2_to_i64` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_pX2_to_i64', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`pX2_to_i64`, 'returnType') = 'integer'
attr(`pX2_to_i64`, "inputTypes") = c('_p_posit_2_t')
class(`pX2_to_i64`) = c("SWIGFunction", class('pX2_to_i64'))

# Start of pX2_int

`pX2_int` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_pX2_int', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`pX2_int`, 'returnType') = 'integer'
attr(`pX2_int`, "inputTypes") = c('_p_posit_2_t')
class(`pX2_int`) = c("SWIGFunction", class('pX2_int'))

# Start of pX2_eq

`pX2_eq` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;.Call('R_swig_pX2_eq', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`pX2_eq`, 'returnType') = 'logical'
attr(`pX2_eq`, "inputTypes") = c('_p_posit_2_t', '_p_posit_2_t')
class(`pX2_eq`) = c("SWIGFunction", class('pX2_eq'))

# Start of pX2_le

`pX2_le` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;.Call('R_swig_pX2_le', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`pX2_le`, 'returnType') = 'logical'
attr(`pX2_le`, "inputTypes") = c('_p_posit_2_t', '_p_posit_2_t')
class(`pX2_le`) = c("SWIGFunction", class('pX2_le'))

# Start of pX2_lt

`pX2_lt` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref")
  ;.Call('R_swig_pX2_lt', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`pX2_lt`, 'returnType') = 'logical'
attr(`pX2_lt`, "inputTypes") = c('_p_posit_2_t', '_p_posit_2_t')
class(`pX2_lt`) = c("SWIGFunction", class('pX2_lt'))

# Start of pX2_to_p8

`pX2_to_p8` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;ans = .Call('R_swig_pX2_to_p8', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit8_t", ref=ans);

  ans

}

attr(`pX2_to_p8`, 'returnType') = '_p_posit8_t'
attr(`pX2_to_p8`, "inputTypes") = c('_p_posit_2_t')
class(`pX2_to_p8`) = c("SWIGFunction", class('pX2_to_p8'))

# Start of pX2_to_p16

`pX2_to_p16` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;ans = .Call('R_swig_pX2_to_p16', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit16_t", ref=ans);

  ans

}

attr(`pX2_to_p16`, 'returnType') = '_p_posit16_t'
attr(`pX2_to_p16`, "inputTypes") = c('_p_posit_2_t')
class(`pX2_to_p16`) = c("SWIGFunction", class('pX2_to_p16'))

# Start of pX2_to_pX2

`pX2_to_pX2` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  s_arg2 = as.integer(s_arg2);

  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };

  ;ans = .Call('R_swig_pX2_to_pX2', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`pX2_to_pX2`, 'returnType') = '_p_posit_2_t'
attr(`pX2_to_pX2`, "inputTypes") = c('_p_posit_2_t', 'integer')
class(`pX2_to_pX2`) = c("SWIGFunction", class('pX2_to_pX2'))

# Start of pX2_to_p32

`pX2_to_p32` = function(pA, .copy = FALSE)
{
  if (inherits(pA, "ExternalReference")) pA = slot(pA,"ref")
  ;ans = .Call('R_swig_pX2_to_p32', pA, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit32_t", ref=ans);

  ans

}

attr(`pX2_to_p32`, 'returnType') = '_p_posit32_t'
attr(`pX2_to_p32`, "inputTypes") = c('_p_posit_2_t')
class(`pX2_to_p32`) = c("SWIGFunction", class('pX2_to_p32'))

# Start of convertDoubleToPX2

`convertDoubleToPX2` = function(s_arg1, s_arg2, .copy = FALSE)
{
  s_arg2 = as.integer(s_arg2);

  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };

  ;ans = .Call('R_swig_convertDoubleToPX2', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`convertDoubleToPX2`, 'returnType') = '_p_posit_2_t'
attr(`convertDoubleToPX2`, "inputTypes") = c('numeric', 'integer')
class(`convertDoubleToPX2`) = c("SWIGFunction", class('convertDoubleToPX2'))

# Start of convertPX2ToDouble

`convertPX2ToDouble` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;.Call('R_swig_convertPX2ToDouble', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');

}

attr(`convertPX2ToDouble`, 'returnType') = 'numeric'
attr(`convertPX2ToDouble`, "inputTypes") = c('_p_posit_2_t')
class(`convertPX2ToDouble`) = c("SWIGFunction", class('convertPX2ToDouble'))

# Start of qX2_fdp_add

`qX2_fdp_add` = function(q, pA, s_arg3, .copy = FALSE)
{
  if (inherits(q, "ExternalReference")) q = slot(q,"ref")
  if (inherits(pA, "ExternalReference")) pA = slot(pA,"ref")
  if (inherits(s_arg3, "ExternalReference")) s_arg3 = slot(s_arg3,"ref")
  ;ans = .Call('R_swig_qX2_fdp_add', q, pA, s_arg3, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_quire_2_t", ref=ans);

  ans

}

attr(`qX2_fdp_add`, 'returnType') = '_p_quire_2_t'
attr(`qX2_fdp_add`, "inputTypes") = c('_p_quire_2_t', '_p_posit_2_t', '_p_posit_2_t')
class(`qX2_fdp_add`) = c("SWIGFunction", class('qX2_fdp_add'))

# Start of qX2_fdp_sub

`qX2_fdp_sub` = function(q, pA, s_arg3, .copy = FALSE)
{
  if (inherits(q, "ExternalReference")) q = slot(q,"ref")
  if (inherits(pA, "ExternalReference")) pA = slot(pA,"ref")
  if (inherits(s_arg3, "ExternalReference")) s_arg3 = slot(s_arg3,"ref")
  ;ans = .Call('R_swig_qX2_fdp_sub', q, pA, s_arg3, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_quire_2_t", ref=ans);

  ans

}

attr(`qX2_fdp_sub`, 'returnType') = '_p_quire_2_t'
attr(`qX2_fdp_sub`, "inputTypes") = c('_p_quire_2_t', '_p_posit_2_t', '_p_posit_2_t')
class(`qX2_fdp_sub`) = c("SWIGFunction", class('qX2_fdp_sub'))

# Start of qX2_to_pX2

`qX2_to_pX2` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  s_arg2 = as.integer(s_arg2);

  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };

  ;ans = .Call('R_swig_qX2_to_pX2', s_arg1, s_arg2, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_posit_2_t", ref=ans);

  ans

}

attr(`qX2_to_pX2`, 'returnType') = '_p_posit_2_t'
attr(`qX2_to_pX2`, "inputTypes") = c('_p_quire_2_t', 'integer')
class(`qX2_to_pX2`) = c("SWIGFunction", class('qX2_to_pX2'))

# Start of qX2_TwosComplement

`qX2_TwosComplement` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref")
  ;ans = .Call('R_swig_qX2_TwosComplement', s_arg1, as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_quire_2_t", ref=ans);

  ans

}

attr(`qX2_TwosComplement`, 'returnType') = '_p_quire_2_t'
attr(`qX2_TwosComplement`, "inputTypes") = c('_p_quire_2_t')
class(`qX2_TwosComplement`) = c("SWIGFunction", class('qX2_TwosComplement'))

# Start of qX2Clr

`qX2Clr` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_qX2Clr', as.logical(.copy), PACKAGE='SoftPosit');
  ans <- new("_p_quire_2_t", ref=ans);

  ans

}

attr(`qX2Clr`, 'returnType') = '_p_quire_2_t'
class(`qX2Clr`) = c("SWIGFunction", class('qX2Clr'))



#' Add together two numbers.
#'
#' @param i A number.
#' @param ps A number.
#' @param es A number.
#' @return The sum of \code{i} and \code{ps}.
# @examples
# convertToColor(1, 2, 3)
# convertToColor(4, 5, 6)
#' @export
convertToColor <- function (i, ps, es){
  #converts integer to binary then make it to n bits by appending zeros
  #paste converts the output to character type
  #we can find out the value of n by getting the size of as.binary and the number
  #of bits which need to get appended
  #orig="{0:b}".format(i).zfill(ps)
  #how to get the number of bits of as.binary output
  # n = ps + size of as.binary output
  #sum_asbin <- summary(as.binary(i))

  #num <- sum_asbin$`Size[bit]`
  #num <- summary(as.binary(i))$`Size[bit]`

  #orig <- paste(fillUpToBit(as.binary(i), n= num + ps))
  #result <- fillUpToBit(as.binary(i), n= num + ps)

  orig <- paste(as.binary(i,n=ps))

  m <- 0
  regime <- 1
  exponent <- 0
  firstFrac <- 1
  colored <- ""

  if(es > 0){
    exponent <- 1

  }

  e <- 0

  for(c in orig ){

    if(m==0){
      #033[0m this is for reset all
      #colored <- colored +"\033[1;37;41m"+c+"\033[0m"
      #colored <- colored +"\033[1;37;41m"+c+"\033[0m"

      #print("inside m 0")
      #colored <- paste(colored,"\033[1;37;41m",c,"\033[0m",sep = "")
      cat(red(c))


    }

    else if (regime==1){

      if(m==1){
        regS <- c
        #colored <- colored + "\033[1;30;43m"+c

        #colored <- paste(colored,"\033[1;30;43m",c,sep="")
        cat(yellow(c))
      }
      else{
        #print("value of regs")
        #print(regS)
        #by default the value is 0
        if(c==regS){

          #colored <- colored + c

          #colored <- paste(colored,c,sep="")
          cat(yellow(c))

        }
        else{
          regime <- 0
          #colored <- colored + c +"\033[0m"

          #colored <- paste(colored,c,"\033[0m",sep="")
          cat(yellow(c))



        }




      }

    }

    else if(exponent==1){
      if(e==0){
        #colored <- colored + "\033[1;37;44m"+c

        #colored <- paste(colored,"\033[1;37;44m",c,sep="")
        cat(blue(c))
      }

      else{

        #colored <- colored + c

        #colored <- paste(colored,c,sep="")
        cat(blue(c))


      }
      e <- e + 1

      if(e==es){

        #colored <- colored +"\033[0m"


        #colored <- paste(colored,"\033[0m",sep="")
        exponent <- 0


      }






    }

    else{
      if(firstFrac==1){

        #colored <- colored + "\033[1;37;40m"+c

        #colored <- paste(colored, "\033[1;37;40m",c,sep="")
        cat(white(c))
        firstFrac <- 0


      }
      else{


        #colored <- colored + c

        #colored <- paste(colored,c,sep="")
        cat(white(c))


      }



    }

    m <- m + 1

    if(m!=ps && m%%8==0){

      cat(" ")
      #colored <- paste(colored," ",sep="")




    }





  }

  #colored <- colored +"\033[0m"
  #colored <- paste(colored,"\033[0m",sep="")


}

checkinteger =  function(x) {
  x%%1==0
  #x == round(x)
}


checkfloat =  function(x) {
  x%%1!=0
  #x != round(x)
}

callingfunc = function(value){
  y <- function(value) .Call('i64_to_p8',value)

}



setClass("posit8",
         representation(
           v = "integer"),
         contains = "RSWIGStruct")


# @return The sum of \code{i} and \code{ps}.
#@examples
# convertToColor(1, 2, 3)
# convertToColor(4, 5, 6)

######################POSIT8  CLASS###################

#' posit8
#' @description An S4 class to represent posit8
#'
#' @slot v   An input value to be converted to posit8

#' @examples
#' x = new ("posit8" , v = 4L)
#' y = new ("posit8" , v = 5)

#setClass("posit8",
 #        representation(
#           v = "numeric",
           #v = "integer",
 #          x = 'ANY'),
  #       contains = "RSWIGStruct")

setClass("posit8",
         representation(
           v = "numeric",
           #v = "integer",
           x = 'ANY'))




#' type
#' @name type
#' @description Returns the type of posit or quire.
#'
#' @param x A posit8 or quire8 or posit16 or quire16 or posit32 or quire32 or posit_2 or quire_2 object.

#' @return The type of \code{x}.
#' @examples
#' a = new ("posit8" , v = 3L)
#' type(a)
#' a = new ("quire8")
#' type(a)
#' a = new ("posit16" , v = 3L)
#' type(a)
#' a = new ("quire16")
#' type(a)
#' a = new ("posit32" , v = 3L)
#' type(a)
#' a = new ("quire32")
#' type(a)
#' a = new ("posit_2" , v = 3L , y = 5L)
#' type(a)
#' a = new ("quire_2" , y = 5L)
#' type(a)

setGeneric("type",function(x){

  standardGeneric("type")
})


#' toPosit8
#' @name toPosit8
#' @description Converts posit16 or posit32 or posit_2 object to posit8 object.
#'
#' @param x A posit16 or posit32 or  posit_2 object.

#' @return posit8 object.
#' @examples
#' a = new ("posit16" , v = 3L)
#' b = toPosit8(a)
#' a = new ("posit32" , v = 3L)
#' b = toPosit8(a)
#' a = new ("posit_2" , v = 3L , y = 5L)
#' b = toPosit8(a)
setGeneric("toPosit8",function(x){

  standardGeneric("toPosit8")
})



#' toPosit16
#' @name toPosit16
#' @description Converts posit8 or posit32 or posit_2 object to posit16 object.
#'
#' @param x A posit8 or posit32 or  posit_2 object.

#' @return posit16 object.
#' @examples
#' a = new ("posit8" , v = 3L)
#' b = toPosit16(a)
#' a = new ("posit32" , v = 3L)
#' b = toPosit16(a)
#' a = new ("posit_2" , v = 3L , y = 5L)
#' b = toPosit16(a)


setGeneric("toPosit16",function(x){

  standardGeneric("toPosit16")
})



#' toPosit32
#' @name toPosit32
#' @description Converts posit8 or posit16 or posit_2 object to posit32 object.
#'
#' @param x A posit8 or posit16 or  posit_2 object.

#' @return posit32 object.
#' @examples
#' a = new ("posit8" , v = 3L)
#' b = toPosit32(a)
#' a = new ("posit16" , v = 3L)
#' b = toPosit32(a)
#' a = new ("posit_2" , v = 3L , y = 5L)
#' b = toPosit32(a)
setGeneric("toPosit32",function(x){

  standardGeneric("toPosit32")
})

#' toPosit_2
#' @name toPosit_2
#' @description Converts posit8 or posit16 or posit32 object to posit_2 object.
#'
#' @param x A posit8 or posit16 or  posit32 object.
#' @param w An integer value representing the size of posit.

#' @return posit_2 object.
#' @examples
#' a = new ("posit8" , v = 3L)
#' b = toPosit_2(a,5L)
#' a = new ("posit16" , v = 3L)
#' b = toPosit_2(a,5L)
#' a = new ("posit32" , v = 3L)
#' b = toPosit_2(a,5L)
setGeneric("toPosit_2",function(x,w){

  standardGeneric("toPosit_2")
})



#' toRInt
#' @name toRInt
#' @description Converts posit type object to integer after rounding.
#'
#' @param x A posit8, posit16, posit32 or posit_2 object.


#' @return integer value.
#' @examples
#' a = new ("posit8" , v = 3L)
#' b = toRInt(a)
#' a = new ("posit16" , v = 3L)
#' b = toRInt(a)
#' a = new ("posit32" , v = 3L)
#' b = toRInt(a)
setGeneric("toRInt",function(x){

  standardGeneric("toRInt")
})

#' toInt
#' @name toInt
#' @description Converts posit  type object to integer.
#'
#' @param x A posit8, posit16, posit32 or posit_2 object.


#' @return integer value.
#' @examples
#' a = new ("posit8" , v = 3L)
#' b = toInt(a)
#' a = new ("posit16" , v = 3L)
#' b = toInt(a)
#' a = new ("posit32" , v = 3L)
#' b = toInt(a)
setGeneric("toInt",function(x){

  standardGeneric("toInt")
})

#' rint
#' @name rint
#' @description Rounds to integer in posit type object
#'
#' @param x A posit8, posit16, posit32 or posit_2 object.


#' @return A posit8, posit16, posit32 or posit_2 object.
#' @examples
#' a = new ("posit8" , v = 3.3)
#' b = rint(a)

setGeneric("rint",function(x){

  standardGeneric("rint")
})


#' fma
#' @name fma
#' @description Performs fused multiply-add between posit type objects.
#'
#' @param x A posit8, posit16, posit32 or posit_2 object.
#' @param y A posit8, posit16, posit32 or posit_2 object.
#' @param z A posit8, posit16, posit32 or posit_2 object.


#' @return posit8, posit16, posit32 or posit_2 object.
#' @examples
#' a = new ("posit8" , v = 1L)
#' b = new ("posit8" , v = 2L)
#' c = new ("posit8" , v = 3L)
#' d = fma (a,b,c)

setGeneric("fma",function(x,y,z){

  standardGeneric("fma")
})





#' rshift
#' @name rshift
#' @description Right shifts posit8, posit16 or posit32 object by argument y.
#'
#' @param x A posit8, posit16 or  posit32 object.
#' @param y An integer value representing the times the object should be shifted right.

#' @return posit8, posit16 or posit32 object.
#' @examples
#' a = new ("posit8" , v = 3L)
#' b = rshift(a,5L)
#' a = new ("posit16" , v = 3L)
#' b = rshift(a,5L)
#' a = new ("posit32" , v = 3L)
#' b = rshift(a,5L)
#' a = new ("posit_2" , v = 3L, y = 4L)
#' b = rshift(a,1L)
setGeneric("rshift",function(x,y){

  standardGeneric("rshift")
})




#' lshift
#' @name lshift
#' @description Left shifts posit8, posit16 or posit32 object by argument y.
#'
#' @param x A posit8, posit16 or  posit32 object.
#' @param y An integer value representing the times the object should be shifted left.

#' @return posit8, posit16 or posit32 object.
#' @examples
#' a = new ("posit8" , v = 3L)
#' b = lshift(a,5L)
#' a = new ("posit16" , v = 3L)
#' b = lshift(a,5L)
#' a = new ("posit32" , v = 3L)
#' b = lshift(a,5L)
#' a = new ("posit_2" , v = 4L, y=4L)
#' b = lshift(a,2L)
setGeneric("lshift",function(x,y){

  standardGeneric("lshift")
})



#' AND
#' @name AND
#' @description Performs AND operation on two same posit object types.
#'
#' @param x A posit8, posit16, posit32 or posit_2 object.
#' @param y A posit8, posit16, posit32 or posit_2 object.
#' @return posit8, posit16, posit32 or posit_2 object.



setGeneric("AND",function(x,y){

  standardGeneric("AND")
})

#' XOR
#' @name XOR
#' @description Performs XOR operation on two same posit object types.
#'
#' @param x A posit8, posit16, posit32 or posit_2 object.
#' @param y A posit8, posit16, posit32 or posit_2 object.
#' @return posit8, posit16, posit32 or posit_2 object.
#' @examples
#' a = new ("posit8" , v = 3L)
#' b = new ("posit8" , v = 4L)
#' c = XOR(a,b)
#' a = new ("posit16" , v = 3L)
#' b = new ("posit16" , v = 4L)
#' c = XOR(a,b)
#' a = new ("posit32" , v = 3L)
#' b = new ("posit32" , v = 4L)
#' c = XOR(a,b)
#' a = new ("posit_2", v =4L, y=5L)
#' b = new ("posit_2", v =3L, y=5L)
#' c = XOR(a,b)
setGeneric("XOR",function(x,y){

  standardGeneric("XOR")
})

#' OR
#' @name OR
#' @description Performs OR operation on two same posit object types.
#'
#' @param x A posit8, posit16, posit32 or posit_2 object.
#' @param y A posit8, posit16, posit32 or posit_2 object.
#' @return posit8, posit16, posit32 or posit_2 object.
#' @examples
#' a = new ("posit8" , v = 3L)
#' b = new ("posit8" , v = 4L)
#' c = OR(a,b)
#' a = new ("posit16" , v = 3L)
#' b = new ("posit16" , v = 4L)
#' c = OR(a,b)
#' a = new ("posit32" , v = 3L)
#' b = new ("posit32" , v = 4L)
#' c = OR(a,b)
#' a = new ("posit_2", v =4L, y=5L)
#' b = new ("posit_2", v =3L, y=5L)
#' c = OR(a,b)
setGeneric("OR",function(x,y){

  standardGeneric("OR")
})

#' NOT
#' @name NOT
#' @description Performs invert (NOT) operation on posit object types.
#'
#' @param x A posit8, posit16, posit32 or posit_2 object.

#' @return posit8, posit16, posit32 or posit_2 object.
#' @examples
#' a = new ("posit8" , v = 3L)
#' c = NOT(a)
#' a = new ("posit16" , v = 3L)
#' c = NOT(a)
#' a = new ("posit32" , v = 3L)
#' c = NOT(a)
#' a = new ("posit_2", v =4L, y=5L)
#' c = NOT(a)
setGeneric("NOT",function(x){

  standardGeneric("NOT")
})



#' isNaR
#' @name isNaR
#' @description Posit has only one bit pattern NaR (Not a Real) to represent infinity,
#' undefined and unrepresented values.isNaR returns true or false on the basis of input.
#'
#' @param x A posit8, quire8, posit16, quire16, posit32, quire32, posit_2 or quire_2 object.

#' @return True or False
#' @examples
#' a = new ("posit8" , v = 3L)
#' b = isNaR(a)

setGeneric("isNaR",function(x){

  standardGeneric("isNaR")
})



#' toNaR
#' @name toNaR
#' @description Converts an object type posit to NaR (Not a Real).
#'
#' @param x A posit8, posit16, posit32 or posit_2 object.
#' @examples
#' a = new ("posit8" , v = 3L)
#' b = toNaR(a)

setGeneric("toNaR",function(x){

  standardGeneric("toNaR")
})


setGeneric("fromBits",function(x,y){

  standardGeneric("fromBits")
})


#' toBinary
#' @name toBinary
#' @description Converts posit or quire type object to binary format.
#'
#' @param x A posit8, quire8, posit16, quire16, posit32, quire32, posit_2 or quire_2 object.
#' @return posit8, quire8, posit16, quire16, posit32, quire32, posit_2 or quire_2 output in binary format.
#' @examples
#' a = new ("posit8" , v = 3L)
#' toBinary(a)
setGeneric("toBinary",function(x){

  standardGeneric("toBinary")
})


#' toBinaryFormatted
#' @name toBinaryFormatted
#' @description Converts posit type object to binary format along with
#' color coding.Sign bit are color coded with red , regime bits with yellow, exponent bits with blue
#' and fraction bits with white

#'
#' @param x A posit8, posit16, posit32 or posit_2 object.
#' @return posit8, posit16 or posit32 output in binary format.
# @examples
# a = new ("posit8" , v = 3L)
# toBinaryFormatted(a)
#' @export
setGeneric("toBinaryFormatted",function(x){

  standardGeneric("toBinaryFormatted")
})



#' toHex
#' @name toHex
#' @description Converts posit or quire type object to Hexadecimal format.

#'
#' @param x A posit8, quire8, posit16, quire16, posit32, quire32, posit_2 or quire_2 object.
#' @return posit8, quire8, posit16, quire16, posit32, quire32, posit_2 or quire_2 output in hexadecimal format.
#' @examples
#' a = new ("posit8" , v = -4L)
#' toHex(a)
setGeneric("toHex",function(x){

  standardGeneric("toHex")
})


#' toDouble
#' @name toDouble
#' @description Converts posit type object to type double .

#'
#' @param x A posit8, posit16, posit32 or posit_2 object.
#' @return output in double.
#' @examples
#' a = new ("posit8" , v = 4L)
#' b = toDouble(a)
setGeneric("toDouble",function(x){

  standardGeneric("toDouble")
})






#' @export
setMethod("type",
          c(x = "posit8"),
          function(x){

            cat("posit8")

          })



#' @export
setMethod("toPosit16",
          c(x = "posit8"),
          function(x){

            a = new ("posit16",v = 0L)
            a@x = p8_to_p16(x@x)
            a

          })

#' @export
setMethod("toPosit32",
          c(x = "posit8"),
          function(x){

            a = new ("posit32",v = 0L)
            a@x = p8_to_p32(x@x)
            a

          })

#' @export
setMethod("toPosit_2",
          c(x = "posit8",w = "integer"),
          function(x,w){

            a = new ("posit_2",v = 0L,y = w)
            a@x = p8_to_pX2(x@x,w)
            a

          })



#' @export
setMethod("toRInt",
          c(x = "posit8"),
          function(x){
            p8_to_i64(x@x)

          })


#' @export
setMethod("toInt",
          c(x = "posit8"),
          function(x){
            p8_int(x@x)


          })

#' @export
setMethod("rint",
          c(x = "posit8"),
          function(x){


            x@x = p8_roundToInt(x@x)
            x


          })



#' @export
setMethod("toBinaryFormatted",
          c(x = "posit8"),
          function(x){

            a = x@x
            b = a$v


            convertToColor(b,8,0)


          })



#' @export
setMethod("fma",
          c(x = "posit8",y = "posit8", z="posit8"),
          function(x,y,z){

            a = new ("posit8",v = 0L)
            a@x = p8_mulAdd(y@x,z@x,x@x)
            a


          })

#' @export
setMethod("fma",
          c(x = "posit8",y = "posit8", z="posit8"),
          function(x,y,z){

            a = new ("posit8",v = 0L)
            a@x = p8_mulAdd(y@x,z@x,x@x)
            a


          })

#' @export
setMethod("isNaR",
          c(x = "posit8"),
          function(x){


            posit8_t_isNaR(x@x)

          })

#' @export
setMethod("toNaR",
          c(x = "posit8"),
          function(x){


           x@x = posit8_t_toNaR(x@x)
           x

          })

#' @export
setMethod("fromBits",
          c(x = "posit8",y = "integer"),
          function(x,y){

          posit8_t_fromBits(x@x,y)


          })

#' @export
setMethod("toBinary",
          c(x = "posit8"),
          function(x){

            posit8_t_toBits(x@x)


          })


#' @export
setMethod("toHex",
          c(x = "posit8"),
          function(x){

            posit8_t_toHex(x@x)


          })






#' new
#' @name init_posit8
#' @description Initializes a posit8 object.
#'
#' @param v An integer or a double value.

#' @return posit8 object.
#' @examples
#' a = new ("posit8" , v = 3L)
#' a = new ("posit8" , v = 3)

setMethod("initialize", "posit8", function(.Object, ...) {

  .Object <- callNextMethod()


  if(is.integer(.Object@v)){

    .Object@x = i64_to_p8(.Object@v)

  }

  else{

    .Object@x = convertDoubleToP8(.Object@v)

  }


  validObject(.Object)
  .Object

})



#' show
#' @name show_posit8
#' @description Returns the value of posit8 object on console.This method is invoked whether
#' we call print , show or simply write a posit8 object and hit enter .
#'
#'
#' @param object posit8 object.

#' @return posit8 object.
#' @examples
#' a = new ("posit8" , v = 3L)
#' a
#' show(a)
#' print(a)

setMethod("show", "posit8", function(object) {


  a = convertP8ToDouble(object@x)


  if (a == Inf)
  {
    cat("NAR")
  }
  else
  {
    a = toString(a)
    cat(a)

  }

})


#' +
#' @name add_posit8
#' @description Adds two posit8 type objects.This is to override the default + operator.
#'
#'
#'
#' @param e1 posit8 object.
#' @param e2 posit8 object.

#' @return posit8 object.
#' @examples
#' a = new ("posit8" , v = 3L)
#' b = new ("posit8" , v = 4L)
#' c = a + b


setMethod("+", signature(e1="posit8", e2="posit8"),function(e1,e2) {

  browser()

  a = new ("posit8",v = 0L)
  a@x = p8_add(e1@x,e2@x)

  a


})
#hello world


#' -
#' @name sub_posit8
#' @description Subtracts two posit8 type objects.This is to override the default - operator.
#'
#'
#'
#' @param e1 posit8 object.
#' @param e2 posit8 object.

#' @return posit8 object.
#' @examples
#' a = new ("posit8" , v = 3L)
#' b = new ("posit8" , v = 4L)
#' c = a - b

setMethod("-", signature(e1="posit8", e2="posit8"),function(e1,e2) {

  a = new ("posit8",v = 0L)
  a@x = p8_sub(e1@x,e2@x)


  a


})


#' *
#' @name mul_posit8
#' @description Multiplies two posit8 type objects.This is to override the default * operator.
#'
#'
#'
#' @param e1 posit8 object.
#' @param e2 posit8 object.

#' @return posit8 object.
#' @examples
#' a = new ("posit8" , v = 3L)
#' b = new ("posit8" , v = 4L)
#' c = a * b

setMethod("*", signature(e1="posit8", e2="posit8"),function(e1,e2) {

  a = new ("posit8",v = 0L)
  a@x = p8_mul(e1@x,e2@x)

  a

})


#' /
#' @name div_posit8
#'
#'
#' @description Divides two posit8 type objects.This is to override the default / operator.
#'
#'
#'
#' @param e1 posit8 object.
#' @param e2 posit8 object.

#' @return posit8 object.
#' @examples
#' a = new ("posit8" , v = 3L)
#' b = new ("posit8" , v = 4L)
#' c = a / b

setMethod("/", signature(e1="posit8", e2="posit8"),function(e1,e2) {

  a = new ("posit8",v = 0L)
  a@x = p8_div(e1@x,e2@x)

  a

})

#' ==
#' @name eq_posit8
#' @description Compares two posit8 type objects.This is to override the default == operator.
#'
#'
#'
#' @param e1 posit8 object.
#' @param e2 posit8 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit8" , v = 3L)
#' b = new ("posit8" , v = 4L)
#' a == b
setMethod("==", signature(e1="posit8", e2="posit8"),function(e1,e2) {

  a = new ("posit8",v = 0L)
  p8_eq(e1@x,e2@x)


})



#' NOT EQUALS
#' @name not_eq_posit8
#' @description Compares two posit8 type objects.This is to override the default != operator.
#'
#'
#'
#' @param e1 posit8 object.
#' @param e2 posit8 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit8" , v = 3L)
#' b = new ("posit8" , v = 4L)
#' a != b
setMethod("!=", signature(e1="posit8", e2="posit8"),function(e1,e2) {

  a = new ("posit8",v = 0L)
  !(p8_eq(e1@x,e2@x))


})


#' <=
#' @name less_than_eq_posit8
#' @description Compares two posit8 type objects.This is to override the default <= operator.
#'
#'
#'
#' @param e1 posit8 object.
#' @param e2 posit8 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit8" , v = 3L)
#' b = new ("posit8" , v = 4L)
#' a <= b
setMethod("<=", signature(e1="posit8", e2="posit8"),function(e1,e2) {

  a = new ("posit8",v = 0L)
  p8_le(e1@x,e2@x)

})


#' <
#' @name less_than_posit8
#' @description Compares two posit8 type objects.This is to override the default < operator.
#'
#'
#'
#' @param e1 posit8 object.
#' @param e2 posit8 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit8" , v = 3L)
#' b = new ("posit8" , v = 4L)
#' a < b

setMethod("<", signature(e1="posit8", e2="posit8"),function(e1,e2) {

  a = new ("posit8",v = 0L)
  p8_lt(e1@x,e2@x)


})

#' >=
#' @name greater_than_eq_posit8
#' @description Compares two posit8 type objects.This is to override the default >= operator.
#'
#'
#'
#' @param e1 posit8 object.
#' @param e2 posit8 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit8" , v = 3L)
#' b = new ("posit8" , v = 4L)
#' a >= b

setMethod(">=", signature(e1="posit8", e2="posit8"),function(e1,e2) {

  a = new ("posit8",v = 0L)
  p8_le(e2@x,e1@x)


})


#' >
#' @name greater_than_posit8
#' @description Compares two posit8 type objects.This is to override the default > operator.
#'
#'
#'
#' @param e1 posit8 object.
#' @param e2 posit8 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit8" , v = 3L)
#' b = new ("posit8" , v = 4L)
#' a > b


setMethod(">", signature(e1="posit8", e2="posit8"),function(e1,e2) {

  a = new ("posit8",v = 0L)
  p8_le(e2@x,e1@x)

})





setMethod("+", signature(e1="posit8"),function(e1){

  e1

})


#This is to override unary - operator

setMethod("-", signature(e1="posit8"),function(e1){

  a = new ("posit8", v = 0L)
  a@x = posit8_t_neg (e1@x)
  a

})

#' abs
#' @name abs_posit8
#' @description Returns the absolute value of posit8 object.This is to override the default abs function.
#'
#'
#'
#' @param x posit8 object.

#' @return A posit8 object.
#' @examples
#' a = new ("posit8" , v = -3L)
#' b = abs(a)

setMethod("abs", c(x="posit8"),function(x){

  a = new ("posit8", v = 0L)
  a@x = posit8_t_abs (x@x)
  a

})




#' sqrt
#' @name sqrt_posit8
#'
#' @description Returns the square root posit8 object.This is to override the default sqrt function.
#'
#'
#'
#' @param x posit8 object.

#' @return A posit8 object.
#' @examples
#' a = new ("posit8" , v = 3L)
#' b = sqrt(a)
#' @export
setMethod("sqrt",c(x = "posit8"),function(x){


  x@x = p8_sqrt(x@x)
  x


})



#' @export
setMethod("toDouble",c(x = "posit8"),function(x){
          convertP8ToDouble(x@x)


         })




#' @export
setMethod("rshift",c(x = "posit8",y = "integer"),function(x,y){
    a = new ("posit8",v = 0L)
    a@x = posit8_t_rshift(x@x,y)
    a
})

#' @export
setMethod("lshift",c(x = "posit8",y = "integer"),function(x,y){
    a = new ("posit8",v = 0L)
    a@x = posit8_t_lshift(x@x,y)
    a
})


#' @export
setMethod("AND",c(x = "posit8",y = "posit8"),function(x,y){
  a = new ("posit8",v = 0L)
  a@x = posit8_t_and(x@x,y@x)
  a
})

#' @export
setMethod("XOR",c(x = "posit8",y = "posit8"),function(x,y){
  a = new ("posit8",v = 0L)
  a@x = posit8_t_xor(x@x,y@x)
  a
})

#' @export
setMethod("OR",c(x = "posit8",y = "posit8"),function(x,y){
  a = new ("posit8",v = 0L)
  a@x = posit8_t_or(x@x,y@x)
  a
})

#' @export
setMethod("NOT",c(x = "posit8"),function(x){
  a = new ("posit8",v = 0L)
  a@x = posit8_t_invert(x@x)
  a
})





######################QUIRE8  CLASS###################


#' quire8
#' @description An S4 class to represent quire8
#'
#'
#'

#' @examples
#' a = new ("quire8")

#setClass("quire8",
 #        representation(
  #         v = "numeric",
           #v = "integer",
   #        x = 'ANY'),
    #     contains = "RSWIGStruct")

setClass("quire8",
         representation(
           x = 'ANY'))



#' toPosit
#' @name toPosit
#' @description Converts quire8, quire16, quire32, quire_2 objects to posit8, posit16, posit32, posit_2 respectively.

#' @param x A quire8, quire16, quire32 or quire_2 object.

#' @return posit8, posit16, posit32 or posit_2 object.
#' @examples
#' a = new ("quire8")
#' b = toPosit(a)
#' a = new ("quire16")
#' b = toPosit(a)
#' a = new ("quire32")
#' b = toPosit(a)
#' a = new ("quire_2" , y = 6L)
#' b = toPosit(a)

setGeneric("toPosit",function(x){

  standardGeneric("toPosit")
})


#' clr
#' @name clr
#' @description Clears quire object.

#' @param x A quire8, quire16, quire32 or quire_2 object.

#' @return quire8, quire16, quire32 or quire_2 object.
#' @examples
#' a = new ("quire8")
#' b = clr(a)
#' a = new ("quire16")
#' b = clr(a)
#' a = new ("quire32")
#' b = clr(a)
#' a = new ("quire_2" , y = 6L)
#' b = clr(a)
setGeneric("clr",function(x){

  standardGeneric("clr")
})



#' qma
#' @name qma
#' @description Fused operation (qma) between quire and posit type object.

#' @param x A quire8, quire16, quire32 or quire_2 object.
#' @param y A posit8, posit16, posit32 or posit_2 object.
#' @param z A posit8, posit16, posit32 or posit_2 object.

#' @return quire8, quire16, quire32 or quire_2 object.
#' @examples
#' a = new ("quire8")
#' b = new ("posit8", v = 4L)
#' c = new ("posit8", v = 5L)
#' a = qma (a,b,c)


setGeneric("qma",function(x,y,z){

  standardGeneric("qma")
})


#' qms
#' @name qms
#' @description Fused operation (qms) between quire and posit type object.

#' @param x A quire8, quire16, quire32 or quire_2 object.
#' @param y A posit8, posit16, posit32 or posit_2 object.
#' @param z A posit8, posit16, posit32 or posit_2 object.

#' @return quire8, quire16, quire32 or quire_2 object.
#' @examples
#' a = new ("quire8")
#' b = new ("posit8", v = 4L)
#' c = new ("posit8", v = 5L)
#' a = qms (a,b,c)

setGeneric("qms",function(x,y,z){

  standardGeneric("qms")
})


#' @export
setMethod("type",
          c(x = "quire8"),
          function(x){

            cat("quire8")

          })

#' @export
setMethod("toPosit",
          c(x = "quire8"),
          function(x){

            a = new ("posit8",v = 0L)
            a@x = q8_to_p8(x@x)
            a

          })


#' @export
setMethod("clr",
          c(x = "quire8"),
          function(x){


            x@x = q8Clr();
            x



          })

#' @export
setMethod("qma",
          c(x = "quire8",y = "posit8",z = "posit8"),
          function(x,y,z){


            x@x =  q8_fdp_add(x@x,y@x,z@x)
            x



          })


#' @export
setMethod("qms",
          c(x = "quire8",y = "posit8",z = "posit8"),
          function(x,y,z){


            x@x =  q8_fdp_sub(x@x,y@x,z@x)
            x



          })


#' @export
setMethod("isNaR",
          c(x = "quire8"),
          function(x){


            quire8_t_isNaR(x@x)

          })

#' @export
setMethod("toBinary",
          c(x = "quire8"),
          function(x){

            quire8_t_toBits(x@x)


          })


#' @export
setMethod("toHex",
          c(x = "quire8"),
          function(x){

            quire8_t_toHex(x@x)


          })



#' new
#' @name init_quire8
#'
#' @description Initializes a quire8 object.
#'
#' @return quire8 object.
#' @examples
#' a = new ("quire8")

setMethod("initialize", "quire8", function(.Object, ...) {

  .Object <- callNextMethod()

  .Object@x = q8Clr();


  validObject(.Object)
  .Object

})

#' show
#' @name show_quire8
#' @description Returns the value of quire8 object on console.This method is invoked whether
#' we call print , show or simply write a quire8 object and hit enter .
#'
#'
#' @param object quire8 object.

#' @return quire8 object.
#' @examples
#' a = new ("quire8")
#' a
#' show(a)
#' print(a)
#'
setMethod("show", "quire8", function(object) {


  a = convertP8ToDouble(q8_to_p8(object@x))
  cat(a)

})





###########################POSIT16 CLASS#############################
#' posit16
#' @description An S4 class to represent posit16
#'
#' @slot v   An input value to be converted to posit16

#' @examples
#' x = new ("posit16" , v = 4L)
#' y = new ("posit16" , v = 5)


#setClass("posit16",
 #        representation(
 #          v = "numeric",
           #v = "integer",
  #         x = 'ANY'),
   #      contains = "RSWIGStruct")


setClass("posit16",
         representation(
           v = "numeric",
           x = 'ANY'))





#' @export
setMethod("type",
          c(x = "posit16"),
          function(x){

            cat("posit16")

          })


#' @export
setMethod("toPosit32",
          c(x = "posit16"),
          function(x){
            browser()
            a = new ("posit32",v = 0L)
            a@x = p16_to_p32(x@x)
            a

          })



#' @export
setMethod("toPosit8",
          c(x = "posit16"),
          function(x){

            a = new ("posit8",v = 0L)
            a@x = p16_to_p8(x@x)
            a

          })




#' @export
setMethod("toPosit_2",

          c(x= "posit16",w = "integer"),
          function(x,w){

            a = new ("posit_2",v = 0L,y = w)
            a@x = p16_to_pX2(x@x,w)

            a

          })




#' @export
setMethod("toRInt",
          c(x = "posit16"),
          function(x){
            p16_to_i64(x@x)


            #a@x = p8_to_i64(x@x)
            #a

          })


#' @export
setMethod("toInt",
          c(x = "posit16"),
          function(x){
            p16_int(x@x)


          })

#' @export
setMethod("rint",
          c(x = "posit16"),
          function(x){


            x@x = p16_roundToInt(x@x)
            x


          })

#' @export
setMethod("toDouble",c(x = "posit16"),function(x){
  convertP16ToDouble(x@x)


})



#' @export
setMethod("toBinaryFormatted",
          c(x = "posit16"),
          function(x){

            a = x@x
            b = a$v


            convertToColor(b,16,1)


          })

#' @export
setMethod("fma",
          c(x = "posit16",y = "posit16", z="posit16"),
          function(x,y,z){

            a = new ("posit16",v = 0L)
            a@x = p16_mulAdd(y@x,z@x,x@x)
            a


          })


#' @export
setMethod("isNaR",
          c(x = "posit16"),
          function(x){


            posit16_t_isNaR(x@x)

          })

#' @export
setMethod("toNaR",
          c(x = "posit16"),
          function(x){


            x@x = posit16_t_toNaR(x@x)
            x

          })

#' @export
setMethod("fromBits",
          c(x = "posit16",y = "integer"),
          function(x,y){
            browser()

            posit16_t_fromBits(x@x,y)


          })

#' @export
setMethod("toBinary",
          c(x = "posit16"),
          function(x){

            posit16_t_toBits(x@x)


          })


#' @export
setMethod("toHex",
          c(x = "posit16"),
          function(x){

            posit16_t_toHex(x@x)


          })




#' new
#' @name init_posit16
#' @description Initializes a posit16 object.
#'
#' @param v An integer or a double value.

#' @return posit16 object.
#' @examples
#' a = new ("posit16" , v = 3L)
#' a = new ("posit16" , v = 3)
setMethod("initialize", "posit16", function(.Object, ...) {

  .Object <- callNextMethod()


  if(is.integer(.Object@v)){

    .Object@x = i64_to_p16(.Object@v)

  }

  else{

    .Object@x = convertDoubleToP16(.Object@v)

  }


  validObject(.Object)
  .Object

})



#' show
#' @name show_posit16
#' @description Returns the value of posit16 object on console.This method is invoked whether
#' we call print , show or simply write a posit16 object and hit enter .
#'
#'
#' @param object posit16 object.

#' @return posit16 object.
#' @examples
#' a = new ("posit16" , v = 3L)
#' a
#' show(a)
#' print(a)
setMethod("show", "posit16", function(object) {
browser()
  j = object@x
  k = j$v



  a = convertP16ToDouble(object@x)

  if (a == Inf)
  {
    cat("NAR")
  }
  else
  {
    a = toString(a)
    cat(a)

  }

})


#' +
#' @name add_posit16
#' @description Adds two posit16 type objects.This is to override the default + operator.
#'
#'
#'
#' @param e1 posit16 object.
#' @param e2 posit16 object.

#' @return posit16 object.
#' @examples
#' a = new ("posit16" , v = 3L)
#' b = new ("posit16" , v = 4L)
#' c = a + b
#'
setMethod("+", signature(e1="posit16", e2="posit16"),function(e1,e2) {

  a = new ("posit16",v = 0L)
  a@x = p16_add(e1@x,e2@x)

  a


})


#' -
#' @name sub_posit16
#' @description Subtracts two posit16 type objects.This is to override the default - operator.
#'
#'
#'
#' @param e1 posit16 object.
#' @param e2 posit16 object.

#' @return posit16 object.
#' @examples
#' a = new ("posit16" , v = 3L)
#' b = new ("posit16" , v = 4L)
#' c = a - b
#'
setMethod("-", signature(e1="posit16", e2="posit16"),function(e1,e2) {

  a = new ("posit16",v = 0L)
  a@x = p16_sub(e1@x,e2@x)


  a


})


#' *
#' @name mul_posit16
#' @description Multiplies two posit16 type objects.This is to override the default * operator.
#'
#'
#'
#' @param e1 posit16 object.
#' @param e2 posit16 object.

#' @return posit16 object.
#' @examples
#' a = new ("posit16" , v = 3L)
#' b = new ("posit16" , v = 4L)
#' c = a * b
setMethod("*", signature(e1="posit16", e2="posit16"),function(e1,e2) {

  a = new ("posit16",v = 0L)
  a@x = p16_mul(e1@x,e2@x)

  a

})


#' /
#' @name div_posit16
#' @description Divides two posit16 type objects.This is to override the default / operator.
#'
#'
#'
#' @param e1 posit16 object.
#' @param e2 posit16 object.

#' @return posit16 object.
#' @examples
#' a = new ("posit16" , v = 3L)
#' b = new ("posit16" , v = 4L)
#' c = a / b

setMethod("/", signature(e1="posit16", e2="posit16"),function(e1,e2) {

  a = new ("posit16",v = 0L)
  a@x = p16_div(e1@x,e2@x)

  a

})


#' ==
#' @name eq_posit16
#' @description Compares two posit16 type objects.This is to override the default == operator.
#'
#'
#'
#' @param e1 posit16 object.
#' @param e2 posit16 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit16" , v = 3L)
#' b = new ("posit16" , v = 4L)
#' a == b
setMethod("==", signature(e1="posit16", e2="posit16"),function(e1,e2) {

  a = new ("posit16",v = 0L)
  p16_eq(e1@x,e2@x)


})

#' NOT EQUALS
#' @name not_eq_posit16
#' @description Compares two posit16 type objects.This is to override the default != operator.
#'
#'
#'
#' @param e1 posit16 object.
#' @param e2 posit16 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit16" , v = 3L)
#' b = new ("posit16" , v = 4L)
#' a != b
setMethod("!=", signature(e1="posit16", e2="posit16"),function(e1,e2) {

  a = new ("posit16",v = 0L)
  !(p16_eq(e1@x,e2@x))


})

#' <=
#' @name less_than_eq_posit16
#' @description Compares two posit16 type objects.This is to override the default <= operator.
#'
#'
#'
#' @param e1 posit16 object.
#' @param e2 posit16 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit16" , v = 3L)
#' b = new ("posit16" , v = 4L)
#' a <= b
setMethod("<=", signature(e1="posit16", e2="posit16"),function(e1,e2) {

  a = new ("posit16",v = 0L)
  p16_le(e1@x,e2@x)

})


#' <
#' @name less_than_posit16
#' @description Compares two posit16 type objects.This is to override the default < operator.
#'
#'
#'
#' @param e1 posit16 object.
#' @param e2 posit16 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit16" , v = 3L)
#' b = new ("posit16" , v = 4L)
#' a < b
setMethod("<", signature(e1="posit16", e2="posit16"),function(e1,e2) {

  a = new ("posit16",v = 0L)
  p16_lt(e1@x,e2@x)


})

#' >=
#' @name greater_than_eq_posit16
#' @description Compares two posit16 type objects.This is to override the default >= operator.
#'
#'
#'
#' @param e1 posit16 object.
#' @param e2 posit16 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit16" , v = 3L)
#' b = new ("posit16" , v = 4L)
#' a >= b

setMethod(">=", signature(e1="posit16", e2="posit16"),function(e1,e2) {

  a = new ("posit16",v = 0L)
  p16_le(e2@x,e1@x)


})

#' >
#' @name greater_than_posit16
#' @description Compares two posit16 type objects.This is to override the default > operator.
#'
#'
#'
#' @param e1 posit16 object.
#' @param e2 posit16 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit16" , v = 3L)
#' b = new ("posit16" , v = 4L)
#' a > b

setMethod(">", signature(e1="posit16", e2="posit16"),function(e1,e2) {

  a = new ("posit16",v = 0L)
  p16_le(e2@x,e1@x)

})



#' sqrt
#' @name sqrt_posit16
#' @description Returns the square root posit16 object.This is to override the default sqrt function.
#'
#'
#'
#' @param x posit16 object.

#' @return A posit16 object.
#' @examples
#' a = new ("posit16" , v = 3L)
#' b = sqrt(a)
#' @export

#' @export
setMethod("sqrt",c(x = "posit16"),function(x){
  x@x = p16_sqrt(x@x)
  x


})


#This is to override unary + operator

setMethod("+", signature(e1="posit16"),function(e1){

  e1

})


#This is to override unary - operator

setMethod("-", signature(e1="posit16"),function(e1){

  a = new ("posit16", v = 0L)
  a@x = posit16_t_neg (e1@x)
  a

})

#' abs
#' @name abs_posit16
#' @description Returns the absolute value of posit16 object.This is to override the default abs function.
#'
#'
#'
#' @param x posit16 object.

#' @return A posit16 object.
#' @examples
#' a = new ("posit16" , v = -3L)
#' b = abs(a)

setMethod("abs", c(x="posit16"),function(x){

  a = new ("posit16", v = 0L)
  a@x = posit16_t_abs (x@x)
  a

})



#' @export
setMethod("rshift",c(x = "posit16",y = "integer"),function(x,y){
  a = new ("posit16",v = 0L)
  a@x = posit16_t_rshift(x@x,y)
  a
})

#' @export
setMethod("lshift",c(x = "posit16",y = "integer"),function(x,y){
  a = new ("posit16",v = 0L)
  a@x = posit16_t_lshift(x@x,y)
  a
})


#' @export
setMethod("AND",c(x = "posit16",y = "posit16"),function(x,y){
  a = new ("posit16",v = 0L)
  a@x = posit16_t_and(x@x,y@x)
  a
})

#' @export
setMethod("XOR",c(x = "posit16",y = "posit16"),function(x,y){
  a = new ("posit16",v = 0L)
  a@x = posit16_t_xor(x@x,y@x)
  a
})

#' @export
setMethod("OR",c(x = "posit16",y = "posit16"),function(x,y){
  a = new ("posit16",v = 0L)
  a@x = posit16_t_or(x@x,y@x)
  a
})

#' @export
setMethod("NOT",c(x = "posit16"),function(x){
  a = new ("posit16",v = 0L)
  a@x = posit16_t_invert(x@x)
  a
})




#########################QUIRE 16##################################

#' quire16
#' @description An S4 class to represent quire16
#'
#'
#'

#' @examples
#' a = new ("quire16")
#setClass("quire16",
 #        representation(
 #          v = "numeric",
           #v = "integer",
  #         x = 'ANY'),
   #      contains = "RSWIGStruct")

setClass("quire16",
         representation(
           v = "numeric",
           x = 'ANY'))




#' @export
setMethod("type",
          c(x = "quire16"),
          function(x){

            cat("quire16")

          })

#' @export
setMethod("toPosit",
          c(x = "quire16"),
          function(x){

            a = new("posit16",v=0L)
            a@x = q16_to_p16(x@x)
            a

          })


#' @export
setMethod("clr",
          c(x = "quire16"),
          function(x){


            x@x = q16Clr();
            x



          })


#' new
#' @name init_quire16
#' @description Initializes a quire16 object.
#'
#' @return quire16 object.
#' @examples
#' a = new ("quire16")
setMethod("initialize", "quire16", function(.Object, ...) {

  .Object <- callNextMethod()

  .Object@x = q16Clr();


  validObject(.Object)
  .Object

})

#' show
#' @name show_quire16
#' @description Returns the value of quire16 object on console.This method is invoked whether
#' we call print , show or simply write a quire16 object and hit enter .
#'
#'
#' @param object quire16 object.

#' @return quire16 object.
#' @examples
#' a = new ("quire16")
#' a
#' show(a)
#' print(a)
#'
setMethod("show", "quire16", function(object) {


  a = convertP16ToDouble(q16_to_p16(object@x))
  cat(a)

})


#' @export
setMethod("qma",
          c(x = "quire16",y = "posit16",z = "posit16"),
          function(x,y,z){


            x@x =  q16_fdp_add(x@x,y@x,z@x)
            x



          })


#' @export
setMethod("qms",
          c(x = "quire16",y = "posit16",z = "posit16"),
          function(x,y,z){


            x@x =  q16_fdp_sub(x@x,y@x,z@x)
            x



          })



#' @export
setMethod("isNaR",
          c(x = "quire16"),
          function(x){


            quire16_t_isNaR(x@x)

          })

#' @export
setMethod("toBinary",
          c(x = "quire16"),
          function(x){

            quire16_t_toBits(x@x)


          })


#' @export
setMethod("toHex",
          c(x = "quire16"),
          function(x){

            quire16_t_toHex(x@x)


          })




###########################POSIT32 CLASS#############################

#' posit32
#' @description An S4 class to represent posit32
#'
#' @slot v   An input value to be converted to posit32

#' @examples
#' x = new ("posit32" , v = 4L)
#' y = new ("posit32" , v = 5)


#setClass("posit32",
  #       representation(
   #        v = "numeric",
           #v = "integer",
    #       x = 'ANY'),
     #    contains = "RSWIGStruct")

setClass("posit32",
         representation(
           v = "numeric",
           x = 'ANY'))



#' @export
setMethod("type",
          c(x = "posit32"),
          function(x){

            cat("posit32")

          })


#' @export
setMethod("toPosit8",
          c(x = "posit32"),
          function(x){

            a = new ("posit8",v = 0L)
            a@x = p32_to_p8(x@x)
            a

          })

#' @export
setMethod("toPosit16",
          c(x = "posit32"),
          function(x){

            a = new ("posit16",v = 0L)
            a@x = p32_to_p16(x@x)
            a

          })

#' @export
setMethod("toPosit_2",
          c(x = "posit32",w = "integer"),
          function(x,w){

            a = new ("posit_2",v = 0L,y = w)
            a@x = p32_to_pX2(x@x,w)
            a

          })


#' @export
setMethod("toRInt",
          c(x = "posit32"),
          function(x){
            p32_to_i64(x@x)


          })


#' @export
setMethod("toInt",
          c(x = "posit32"),
          function(x){
            p32_int(x@x)


          })

#' @export
setMethod("rint",
          c(x = "posit32"),
          function(x){


            x@x = p32_roundToInt(x@x)
            x


          })

#' @export
setMethod("toDouble",c(x = "posit32"),function(x){
  convertP32ToDouble(x@x)


})




#' @export
setMethod("toBinaryFormatted",
          c(x = "posit32"),
          function(x){

            a = x@x
            b = a$v


            convertToColor(b,32,2)


          })


#' @export
setMethod("fma",
          c(x = "posit32",y = "posit32", z="posit32"),
          function(x,y,z){

            a = new ("posit32",v = 0L)
            a@x = p32_mulAdd(y@x,z@x,x@x)
            a


          })

#' @export
setMethod("isNaR",
          c(x = "posit32"),
          function(x){


            posit32_t_isNaR(x@x)

          })

#' @export
setMethod("toNaR",
          c(x = "posit32"),
          function(x){


            x@x = posit32_t_toNaR(x@x)
            x

          })

#' @export
setMethod("fromBits",
          c(x = "posit32",y = "integer"),
          function(x,y){

            posit32_t_fromBits(x@x,y)


          })

#' @export
setMethod("toBinary",
          c(x = "posit32"),
          function(x){

            posit32_t_toBits(x@x)


          })


#' @export
setMethod("toHex",
          c(x = "posit32"),
          function(x){

            posit32_t_toHex(x@x)


          })






#' new
#' @name init_posit32
#' @description Initializes a posit32 object.
#'
#' @param v An integer or a double value.

#' @return posit32 object.
#' @examples
#' a = new ("posit32" , v = 30L)
#' a = new ("posit32" , v = 30)
setMethod("initialize", "posit32", function(.Object, ...) {

  .Object <- callNextMethod()


  if(is.integer(.Object@v)){

    .Object@x = i64_to_p32(.Object@v)

  }

  else{

    .Object@x = convertDoubleToP32(.Object@v)

  }


  validObject(.Object)
  .Object

})



#' show
#' @name show_posit32
#' @description Returns the value of posit32 object on console.This method is invoked whether
#' we call print , show or simply write a posit32 object and hit enter .
#'
#'
#' @param object posit32 object.

#' @return posit32 object.
#' @examples
#' a = new ("posit32" , v = 3L)
#' a
#' show(a)
#' print(a)
setMethod("show", "posit32", function(object) {

  #ALERT



  a = convertP32ToDouble(object@x)




  if (a == Inf)
  {
    cat("NAR")
  }
  else
  {
    a = toString(a)
    cat(a)

  }


})



#' +
#' @name add_posit32
#' @description Adds two posit32 type objects.This is to override the default + operator.
#'
#'
#'
#' @param e1 posit32 object.
#' @param e2 posit32 object.

#' @return posit32 object.
#' @examples
#' a = new ("posit32" , v = 3L)
#' b = new ("posit32" , v = 4L)
#' c = a + b
#'
setMethod("+", signature(e1="posit32", e2="posit32"),function(e1,e2) {

  a = new ("posit32",v = 0L)
  a@x = p32_add(e1@x,e2@x)

  a


})


#' -
#' @name sub_posit32
#' @description Subtracts two posit32 type objects.This is to override the default - operator.
#'
#'
#'
#' @param e1 posit32 object.
#' @param e2 posit32 object.

#' @return posit32 object.
#' @examples
#' a = new ("posit32" , v = 3L)
#' b = new ("posit32" , v = 4L)
#' c = a - b

setMethod("-", signature(e1="posit32", e2="posit32"),function(e1,e2) {

  a = new ("posit32",v = 0L)
  a@x = p32_sub(e1@x,e2@x)


  a


})


#' *
#' @name mul_posit32
#' @description Multiplies two posit32 type objects.This is to override the default * operator.
#'
#'
#'
#' @param e1 posit32 object.
#' @param e2 posit32 object.

#' @return posit32 object.
#' @examples
#' a = new ("posit32" , v = 3L)
#' b = new ("posit32" , v = 4L)
#' c = a * b
setMethod("*", signature(e1="posit32", e2="posit32"),function(e1,e2) {

  a = new ("posit32",v = 0L)
  a@x = p32_mul(e1@x,e2@x)

  a

})


#' /
#' @name div_posit32
#' @description Divides two posit32 type objects.This is to override the default / operator.
#'
#'
#'
#' @param e1 posit32 object.
#' @param e2 posit32 object.

#' @return posit32 object.
#' @examples
#' a = new ("posit32" , v = 3L)
#' b = new ("posit32" , v = 4L)
#' c = a / b

setMethod("/", signature(e1="posit32", e2="posit32"),function(e1,e2) {

  a = new ("posit32",v = 0L)
  a@x = p32_div(e1@x,e2@x)

  a

})


#' ==
#' @name eq_posit32
#' @description Compares two posit32 type objects.This is to override the default == operator.
#'
#'
#'
#' @param e1 posit32 object.
#' @param e2 posit32 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit32" , v = 3L)
#' b = new ("posit32" , v = 4L)
#' a == b
setMethod("==", signature(e1="posit32", e2="posit32"),function(e1,e2) {

  a = new ("posit32",v = 0L)
  p32_eq(e1@x,e2@x)


})

#' NOT EQUALS
#' @name not_eq_posit32
#' @description Compares two posit32 type objects.This is to override the default != operator.
#'
#'
#'
#' @param e1 posit32 object.
#' @param e2 posit32 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit32" , v = 3L)
#' b = new ("posit32" , v = 4L)
#' a != b

setMethod("!=", signature(e1="posit32", e2="posit32"),function(e1,e2) {

  a = new ("posit32",v = 0L)
  !(p32_eq(e1@x,e2@x))


})

#' <=
#' @name less_than_eq_posit32
#' @description Compares two posit32 type objects.This is to override the default <= operator.
#'
#'
#'
#' @param e1 posit32 object.
#' @param e2 posit32 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit32" , v = 3L)
#' b = new ("posit32" , v = 4L)
#' a <= b

setMethod("<=", signature(e1="posit32", e2="posit32"),function(e1,e2) {

  a = new ("posit32",v = 0L)
  p32_le(e1@x,e2@x)

})


#' <
#' @name less_than_posit32
#' @description Compares two posit32 type objects.This is to override the default < operator.
#'
#'
#'
#' @param e1 posit32 object.
#' @param e2 posit32 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit32" , v = 3L)
#' b = new ("posit32" , v = 4L)
#' a < b
setMethod("<", signature(e1="posit32", e2="posit32"),function(e1,e2) {

  a = new ("posit32",v = 0L)
  p32_lt(e1@x,e2@x)


})

#' >=
#' @name greater_than_eq_posit32
#' @description Compares two posit32 type objects.This is to override the default >= operator.
#'
#'
#'
#' @param e1 posit32 object.
#' @param e2 posit32 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit32" , v = 3L)
#' b = new ("posit32" , v = 4L)
#' a >= b

setMethod(">=", signature(e1="posit32", e2="posit32"),function(e1,e2) {

  a = new ("posit32",v = 0L)
  p32_le(e2@x,e1@x)


})


#' >
#' @name greater_than_posit32
#' @description Compares two posit32 type objects.This is to override the default > operator.
#'
#'
#'
#' @param e1 posit32 object.
#' @param e2 posit32 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit32" , v = 3L)
#' b = new ("posit32" , v = 4L)
#' a > b

setMethod(">", signature(e1="posit32", e2="posit32"),function(e1,e2) {

  a = new ("posit32",v = 0L)
  p32_le(e2@x,e1@x)

})


#' sqrt
#' @name sqrt_posit32
#' @description Returns the square root posit32 object.This is to override the default sqrt function.
#'
#'
#'
#' @param x posit32 object.

#' @return A posit32 object.
#' @examples
#' a = new ("posit32" , v = 3L)
#' b = sqrt(a)
#' @export
setMethod("sqrt",c(x = "posit32"),function(x){
  x@x = p32_sqrt(x@x)
  x


})


#This is to override unary + operator

setMethod("+", signature(e1="posit32"),function(e1){

  e1

})


#This is to override unary - operator

setMethod("-", signature(e1="posit32"),function(e1){

  a = new ("posit32", v = 0L)
  a@x = posit32_t_neg (e1@x)
  a

})

#' abs
#' @name abs_posit32
#' @description Returns the absolute value of posit32 object.This is to override the default abs function.
#'
#'
#'
#' @param x posit32 object.

#' @return A posit32 object.
#' @examples
#' a = new ("posit32" , v = -3L)
#' b = abs(a)

setMethod("abs", c(x="posit32"),function(x){

  a = new ("posit32", v = 0L)
  a@x = posit32_t_abs (x@x)
  a

})



#' @export
setMethod("rshift",c(x = "posit32",y = "integer"),function(x,y){
  a = new ("posit32",v = 0L)
  a@x = posit32_t_rshift(x@x,y)
  a
})

#' @export
setMethod("lshift",c(x = "posit32",y = "integer"),function(x,y){
  a = new ("posit32",v = 0L)
  a@x = posit32_t_lshift(x@x,y)
  a
})


#' @export
setMethod("AND",c(x = "posit32",y = "posit32"),function(x,y){
  a = new ("posit32",v = 0L)
  a@x = posit32_t_and(x@x,y@x)
  a
})

#' @export
setMethod("XOR",c(x = "posit32",y = "posit32"),function(x,y){
  a = new ("posit32",v = 0L)
  a@x = posit32_t_xor(x@x,y@x)
  a
})

#' @export
setMethod("OR",c(x = "posit32",y = "posit32"),function(x,y){
  a = new ("posit32",v = 0L)
  a@x = posit32_t_or(x@x,y@x)
  a
})

#' @export
setMethod("NOT",c(x = "posit32"),function(x){
  a = new ("posit32",v = 0L)
  a@x = posit32_t_invert(x@x)
  a
})


##########################QUIRE32 CLASS###############################################


#' quire32
#' @description An S4 class to represent quire32
#'
#'
#'

#' @examples
#' a = new ("quire32")
#setClass("quire32",
 #        representation(
  #         v = "numeric",
           #v = "integer",
   #        x = 'ANY'),
    #     contains = "RSWIGStruct")

setClass("quire32",
         representation(
           x = 'ANY'))



#' @export
setMethod("type",
          c(x = "quire32"),
          function(x){

            cat("quire32")

          })

#' @export
setMethod("toPosit",
          c(x = "quire32"),
          function(x){

            a = new("posit32",v=0L)
            a@x = q32_to_p32(x@x)
            a

          })


#' @export
setMethod("clr",
          c(x = "quire32"),
          function(x){


            x@x = q32Clr();
            x



          })

#' new
#' @name init_quire32
#' @description Initializes a quire32 object.
#'
#' @return quire32 object.
#' @examples
#' a = new ("quire32")
#'
setMethod("initialize", "quire32", function(.Object, ...) {

  .Object <- callNextMethod()

  .Object@x = q32Clr();


  validObject(.Object)
  .Object

})

#' show
#' @name show_quire32
#' @description Returns the value of quire32 object on console.This method is invoked whether
#' we call print , show or simply write a quire32 object and hit enter .
#'
#'
#' @param object quire32 object.

#' @return quire32 object.
#' @examples
#' a = new ("quire32")
#' a
#' show(a)
#' print(a)
#'
setMethod("show", "quire32", function(object) {


  a = convertP32ToDouble(q32_to_p32(object@x))
  cat(a)

})



#' @export
setMethod("qma",
          c(x = "quire32",y = "posit32",z = "posit32"),
          function(x,y,z){


            x@x =  q32_fdp_add(x@x,y@x,z@x)
            x



          })


#' @export
setMethod("qms",
          c(x = "quire32",y = "posit32",z = "posit32"),
          function(x,y,z){


            x@x =  q32_fdp_sub(x@x,y@x,z@x)
            x



          })

#' @export
setMethod("isNaR",
          c(x = "quire32"),
          function(x){


            quire32_t_isNaR(x@x)

          })

#' @export
setMethod("toBinary",
          c(x = "quire32"),
          function(x){

            quire32_t_toBits(x@x)


          })


#' @export
setMethod("toHex",
          c(x = "quire32"),
          function(x){

            quire32_t_toHex(x@x)


          })




##########################POSIT_2 CLASS###############################################

#' posit_2
#' @description An S4 class to represent posit_2
#'
#' @slot v   An input value to be converted to posit_2
#' @slot y   An integer value representing the size of posit

#' @examples
#' a = new ("posit_2" , v = 4L , y = 6L)
#' b = new ("posit_2" , v = 5 , y = 8L)
#setClass("posit_2",
 #        representation(
#           v = "numeric",
           #v = "integer",
 #          x = 'ANY',
  #         y = "integer"),
   #      contains = "RSWIGStruct")

setClass("posit_2",
         representation(
           v = "numeric",
           x = 'ANY',
           y = "integer"))











#' @export
setMethod("type",
          c(x = "posit_2"),
          function(x){
            a = x@y
            cat("posit",a,"_2",sep="")


          })


#' @export
setMethod("toPosit8",
          c(x = "posit_2"),
          function(x){

            a = new ("posit8",v = 0L)
            a@x = pX2_to_p8(x@x)
            a

          })

#' @export
setMethod("toPosit16",
          c(x = "posit_2"),
          function(x){

            a = new ("posit16",v = 0L)
            a@x = pX2_to_p16(x@x)
            a

          })


#' @export
setMethod("toPosit32",
          c(x = "posit_2"),
          function(x){

            a = new ("posit32",v = 0L)
            a@x = pX2_to_p32(x@x)
            a

          })


#' @export
setMethod("toPosit_2",

          c(x = "posit_2",w = "integer"),
          function(x,w){

            a = new ("posit_2",v = 0L,y = w)
            a@x = pX2_to_pX2(x@x,w)
            a@y = w
            a

          })

#' @export
setMethod("toRInt",
          c(x = "posit_2"),
          function(x){
            pX2_to_i64(x@x)


          })


#' @export
setMethod("toInt",
          c(x = "posit_2"),
          function(x){
            pX2_int(x@x)


          })

#' @export
setMethod("rint",
          c(x = "posit_2"),
          function(x){


            x@x = pX2_roundToInt(x@x,x@y)
            x


          })


#' @export
setMethod("toDouble",c(x = "posit_2"),function(x){
  convertPX2ToDouble(x@x)


})


#' @export
setMethod("toBinaryFormatted",
          c(x = "posit_2"),
          function(x){

            a = x@x
            b = a$v
            #print(b)


            #convertToColor(b,x@y,2)
            #bitwShiftR(8, 2)

            convertToColor(bitwShiftR(b,32-x@y),x@y,2)


          })


#' @export
setMethod("fma",
          c(x = "posit_2",y = "posit_2", z="posit_2"),
          function(x,y,z){

            a = new ("posit_2",v = 0L,y = x@y)
            a@x = pX2_mulAdd(y@x,z@x,x@x,x@y)
            a


          })


#' @export
setMethod("isNaR",
          c(x = "posit_2"),
          function(x){


            posit_2_t_isNaR(x@x)

          })

#' @export
setMethod("toNaR",
          c(x = "posit_2"),
          function(x){


            x@x = posit_2_t_toNaR(x@x)
            x

          })

#' @export
setMethod("fromBits",
          c(x = "posit_2",y = "integer"),
          function(x,y){

            posit_2_t_fromBits(x@x,y)


          })

#' @export
setMethod("toBinary",
          c(x = "posit_2"),
          function(x){

            posit_2_t_toBits(x@x,x@y)


          })


#' @export
setMethod("toHex",
          c(x = "posit_2"),
          function(x){

            posit_2_t_toHex(x@x,x@y)


          })

#' new
#' @name init_posit_2
#' @description Initializes a posit_2 object.
#'
#' @param v An integer or a double value.
#' @param y An integer value representing the size of posit.

#' @return posit_2 object.
#' @examples
#' a = new ("posit_2" , v = 30L , y = 16L)
#' a = new ("posit_2" , v = 30 , y = 16L)


setMethod("initialize", "posit_2", function(.Object, ...) {

  .Object <- callNextMethod()


  if(is.integer(.Object@v)){

    .Object@x = i64_to_pX2(.Object@v,.Object@y)

  }

  else{

    .Object@x = convertDoubleToPX2(.Object@v,.Object@y)

  }


  validObject(.Object)
  .Object

})


#' +
#' @name add_posit_2
#' @description Adds two posit_2 type objects.This is to override the default + operator.
#'
#'
#'
#' @param e1 posit_2 object.
#' @param e2 posit_2 object.

#' @return posit_2 object.
#' @examples
#' a = new ("posit_2" , v = 3L , y = 4L )
#' b = new ("posit_2" , v = 4L , y = 4L )
#' c = a + b
#'
setMethod("+", signature(e1="posit_2", e2="posit_2"),function(e1,e2) {



  a = new ("posit_2",v =0L,y=e1@y)

  if(e1@y == e2@y)
  {
    a@x = pX2_add(e1@x,e2@x,e1@y)

  }
  else{

    cat("TypeError: Unsupported operand type(s) for +:posit",e1@y,"_2 and posit",e2@y,"_2",sep="")

  }

  a


})


#' -
#' @name sub_posit_2
#' @description Subtracts two posit_2 type objects.This is to override the default - operator.
#'
#'
#'
#' @param e1 posit_2 object.
#' @param e2 posit_2 object.

#' @return posit_2 object.
#' @examples
#' a = new ("posit_2" , v = 3L , y = 4L )
#' b = new ("posit_2" , v = 4L , y = 4L )
#' c = a - b
#'
setMethod("-", signature(e1="posit_2", e2="posit_2"),function(e1,e2) {



  a = new ("posit_2",v =0L,y=e1@y)

  if(e1@y == e2@y)
  {
    a@x = pX2_sub(e1@x,e2@x,e1@y)

  }
  else{

    cat("TypeError: Unsupported operand type(s) for -:posit",e1@y,"_2 and posit",e2@y,"_2",sep="")

  }

  a


})


#' *
#' @name mul_posit_2
#' @description Multiplies two posit_2 type objects.This is to override the default * operator.
#'
#'
#'
#' @param e1 posit_2 object.
#' @param e2 posit_2 object.

#' @return posit_2 object.
#' @examples
#' a = new ("posit_2" , v = 3L , y = 4L )
#' b = new ("posit_2" , v = 4L , y = 4L )
#' c = a * b
#'

setMethod("*", signature(e1="posit_2", e2="posit_2"),function(e1,e2) {

  a = new ("posit_2",v =0L,y=e1@y)

  if(e1@y == e2@y)
  {
    a@x = pX2_mul(e1@x,e2@x,e1@y)

  }
  else{

    cat("TypeError: Unsupported operand type(s) for *:posit",e1@y,"_2 and posit",e2@y,"_2",sep="")

  }

  a
})


#' /
#' @name div_posit_2
#' @description Divides two posit_2 type objects.This is to override the default / operator.
#'
#'
#'
#' @param e1 posit_2 object.
#' @param e2 posit_2 object.

#' @return posit_2 object.
#' @examples
#' a = new ("posit_2" , v = 3L , y = 4L )
#' b = new ("posit_2" , v = 4L , y = 4L )
#' c = a / b
#'

setMethod("/", signature(e1="posit_2", e2="posit_2"),function(e1,e2) {

  a = new ("posit_2",v =0L,y=e1@y)

  if(e1@y == e2@y)
  {
    a@x = pX2_div(e1@x,e2@x,e1@y)

  }
  else{

    cat("TypeError: Unsupported operand type(s) for *:posit",e1@y,"_2 and posit",e2@y,"_2",sep="")

  }

  a
})


#' ==
#' @name eq_posit_2
#' @description Compares two posit_2 type objects.This is to override the default == operator.
#'
#'
#'
#' @param e1 posit_2 object.
#' @param e2 posit_2 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit_2" , v = 3L , y = 5L)
#' b = new ("posit_2" , v = 4L , y = 5L)
#' a == b

setMethod("==", signature(e1="posit_2", e2="posit_2"),function(e1,e2) {


  pX2_eq(e1@x,e2@x)


})


#' NOT EQUALS
#' @name not_eq_posit_2
#' @description Compares two posit_2 type objects.This is to override the default != operator.
#'
#'
#'
#' @param e1 posit_2 object.
#' @param e2 posit_2 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit_2" , v = 3L , y = 5L)
#' b = new ("posit_2" , v = 4L , y = 5L)
#' a != b

setMethod("!=", signature(e1="posit_2", e2="posit_2"),function(e1,e2) {


  !(pX2_eq(e1@x,e2@x))


})

#' <=
#' @name less_than_eq_posit_2
#' @description Compares two posit_2 type objects.This is to override the default <= operator.
#'
#'
#'
#' @param e1 posit_2 object.
#' @param e2 posit_2 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit_2" , v = 3L , y = 5L)
#' b = new ("posit_2" , v = 4L , y = 5L)
#' a <= b
setMethod("<=", signature(e1="posit_2", e2="posit_2"),function(e1,e2) {


  pX2_le(e1@x,e2@x)

})


#' <
#' @name less_than_posit_2
#' @description Compares two posit_2 type objects.This is to override the default < operator.
#'
#'
#'
#' @param e1 posit_2 object.
#' @param e2 posit_2 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit_2" , v = 3L , y = 5L)
#' b = new ("posit_2" , v = 4L , y = 5L)
#' a < b

setMethod("<", signature(e1="posit_2", e2="posit_2"),function(e1,e2) {


  pX2_lt(e1@x,e2@x)


})

#' >=
#' @name greater_than_eq_posit_2
#' @description Compares two posit_2 type objects.This is to override the default >= operator.
#'
#'
#'
#' @param e1 posit_2 object.
#' @param e2 posit_2 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit_2" , v = 3L , y = 5L)
#' b = new ("posit_2" , v = 4L , y = 5L)
#' a >= b

setMethod(">=", signature(e1="posit_2", e2="posit_2"),function(e1,e2) {


  pX2_le(e2@x,e1@x)


})


#' >
#' @name greater_than_posit_2
#' @description Compares two posit_2 type objects.This is to override the default > operator.
#'
#'
#'
#' @param e1 posit_2 object.
#' @param e2 posit_2 object.

#' @return TRUE or FALSE.
#' @examples
#' a = new ("posit_2" , v = 3L , y = 5L)
#' b = new ("posit_2" , v = 4L , y = 5L)
#' a > b

setMethod(">", signature(e1="posit_2", e2="posit_2"),function(e1,e2) {


  pX2_lt(e2@x,e1@x)

})


#' sqrt
#' @name sqrt_posit_2
#' @description Returns the square root posit_2 object.This is to override the default sqrt function.
#'
#'
#'
#' @param x posit_2 object.

#' @return A posit_2 object.
#' @examples
#' a = new ("posit_2" , v = 3L , y = 5L)
#' b = sqrt(a)
setMethod("sqrt",c(x = "posit_2"),function(x){
  x@x = pX2_sqrt(x@x,x@y)
  x


})



#' show
#' @name show_posit_2
#' @description Returns the value of posit_2 object on console.This method is invoked whether
#' we call print , show or simply write a posit_2 object and hit enter .
#'
#'
#' @param object posit_2 object.

#' @return posit_2 object.
#' @examples
#' a = new ("posit_2" , v = 3L , y = 5L)
#' a
#' show(a)
#' print(a)
setMethod("show", "posit_2", function(object) {

  a = convertPX2ToDouble(object@x)
  if (a == Inf)
  {
   cat("NAR")
  }
  else
  {
    a = toString(a)
    cat(a)

  }


})


#This is to override unary + operator

setMethod("+", signature(e1="posit_2"),function(e1){

  e1

})


#This is to override unary - operator

setMethod("-", signature(e1="posit_2"),function(e1){

  a = new ("posit_2", v = 0L , y = e1@y)
  a@x = posit_2_t_neg (e1@x,e1@y)
  a

})

#' abs
#' @name abs_posit_2
#' @description Returns the absolute value of posit_2 object.This is to override the default abs function.
#'
#'
#'
#' @param x posit_2 object.

#' @return A posit_2 object.
#' @examples
#' a = new ("posit_2" , v = -3L , y = 5L)
#' b = abs(a)

setMethod("abs", c(x="posit_2"),function(x){

  a = new ("posit_2", v = 0L, y = x@y)
  a@x = posit_2_t_abs (x@x,x@y)
  a

})

#' @export
setMethod("rshift",c(x = "posit_2",y = "integer"),function(x,y){
  a = new ("posit_2",v = 0L,y = x@y)
  a@x = posit_2_t_rshift(x@x,y,x@y)
  a
})

#' @export
setMethod("lshift",c(x = "posit_2",y = "integer"),function(x,y){
  a = new ("posit_2",v = 0L,y = x@y)
  a@x = posit_2_t_lshift(x@x,y,x@y)
  a
})


#' @export
setMethod("AND",c(x = "posit_2",y = "posit_2"),function(x,y){
  a = new ("posit_2",v = 0L, y = x@y)
  a@x = posit_2_t_and(x@x,y@x,x@y)
  a
})

#' @export
setMethod("XOR",c(x = "posit_2",y = "posit_2"),function(x,y){
  a = new ("posit_2",v = 0L, y = x@y)
  a@x = posit_2_t_xor(x@x,y@x,x@y)
  a
})

#' @export
setMethod("OR",c(x = "posit_2",y = "posit_2"),function(x,y){
  a = new ("posit_2",v = 0L,y = x@y)
  a@x = posit_2_t_or(x@x,y@x,x@y)
  a
})

#' @export
setMethod("NOT",c(x = "posit_2"),function(x){
  a = new ("posit_2",v = 0L, y = x@y)
  a@x = posit_2_t_invert(x@x,x@y)
  a
})




##########################QUIRE_2 CLASS###############################################




#' quire_2
#' @description An S4 class to represent quire_2
#'
#'
#' @slot y   An integer value representing the size of quire

#' @examples
#' a = new ("quire_2" , y = 6L)
#' b = new ("quire_2" , y = 8L)



#setClass("quire_2",
 #        representation(
  #         v = "numeric",
           #v = "integer",
   #        x = 'ANY',
    #       y = "integer"),
     #    contains = "RSWIGStruct")
setClass("quire_2",
         representation(
           x = 'ANY',
           y = "integer"))



#' @export
setMethod("type",
          c(x = "quire_2"),
          function(x){
            a = x@y
            cat("quire",a,"_2",sep="")




          })

#' @export
setMethod("toPosit",
          c(x = "quire_2"),
          function(x){

            a = new("posit_2",v=0L,y=x@y)
            a@x = qX2_to_pX2(x@x,x@y)
            a

          })


#' @export
setMethod("clr",
          c(x = "quire_2"),
          function(x){


            x@x = qX2Clr();
            x



          })

#' new
#' @name init_quire_2
#' @description Initializes a quire_2 object.
#' @param y size of quire
#'
#' @return quire_2 object.
#' @examples
#' a = new ("quire_2", y = 4L)

setMethod("initialize", "quire_2", function(.Object, ...) {

  .Object <- callNextMethod()

  .Object@x = qX2Clr();



  validObject(.Object)
  .Object

})

#' show
#' @name show_quire_2
#' @description Returns the value of quire_2 object on console.This method is invoked whether
#' we call print , show or simply write a quire_2 object and hit enter .
#'
#'
#' @param object quire_2 object.

#' @return quire_2 object.
#' @examples
#' a = new ("quire_2" , y = 2L)
#' a
#' show(a)
#' print(a)
#'
setMethod("show", "quire_2", function(object) {


  a = convertPX2ToDouble(qX2_to_pX2(object@x,object@y))
  cat(a)

})


#' @export
setMethod("qma",
          c(x = "quire_2",y = "posit_2",z = "posit_2"),
          function(x,y,z){

            #a = new ("posit_2",v=0L,y=x@y)


            x@x =  qX2_fdp_add(x@x,y@x,z@x)
            x



          })


#' @export
setMethod("qms",
          c(x = "quire_2",y = "posit_2",z = "posit_2"),
          function(x,y,z){


            x@x =  qX2_fdp_sub(x@x,y@x,z@x)
            x



          })

#' @export
setMethod("isNaR",
          c(x = "quire_2"),
          function(x){


            quire_2_t_isNaR(x@x)

          })

#' @export
setMethod("toBinary",
          c(x = "quire_2"),
          function(x){

            quire_2_t_toBits(x@x)


          })


#' @export
setMethod("toHex",
          c(x = "quire_2"),
          function(x){

            quire_2_t_toHex(x@x)


          })












